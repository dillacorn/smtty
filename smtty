#!/usr/bin/env bash
# smtty - Steam Machine launcher (gamescope-only)
# Can be run from a bare TTY or from an X11/Wayland session (Hyprland, Sway, KDE, GNOME, etc.).
# Recommended install location:
#   - $HOME/.local/bin/smtty  (user)
#   - /usr/local/bin/smtty    (system-wide)
#
# Modes:
#   Default:
#     Interactive launcher for Steam Gamepad UI (Big Picture) inside gamescope.
#
#   -O
#     Interactively generate ready-to-paste Steam per-game launch options (nested gamescope, no Big Picture) and exit.
#     Lets you choose:
#       - gamescope with or without Steam integration (-e)
#       - background/unfocused FPS limit (-o, from saved config)
#       - flatpak vs native Steam prefix
#
#   -n
#     New interactive setup for smtty config. Prompts for profile name to save.
#
#   -l
#     Use last saved smtty config immediately (no questions).
#     With -l, smtty never kills Steam unless you also pass -S.
#
#   -c <profile>
#     Use specified configuration profile and launch immediately.
#
#   -L
#     List all available configuration profiles and exit.
#
#   -D <profile>
#     Delete specified configuration profile and exit.
#
#   -p
#     Print saved config summary and exit.
#
#   -k
#     Kill any running gamescope processes and exit.
#     If a profile defines a POST_CMD, it is run after audio restore.
#
#   -d
#     Detach gamescope (run in background, return to shell).
#
#   -S
#     Kill any running Steam client before launching gamescope (no prompt).

set -euo pipefail

# ---------------- colors / logging ----------------
RED=$'\033[0;31m'
YELLOW=$'\033[1;33m'
GREEN=$'\033[0;32m'
BLUE=$'\033[0;34m'
NC=$'\033[0m'

print_error() {
  printf '%s[ERROR]%s %s\n' "$RED" "$NC" "$*" >&2
}

print_warn() {
  printf '%s[WARN]%s %s\n' "$YELLOW" "$NC" "$*"
}

print_info() {
  printf '%s[INFO]%s %s\n' "$BLUE" "$NC" "$*"
}

print_success() {
  printf '%s[OK]%s %s\n' "$GREEN" "$NC" "$*"
}

# ---------------- Steam command (Gamepad UI) ----------------
# Optional override:
#   STEAM_CMD_OVERRIDE='steam -gamepadui -nochatui'
if [[ "${STEAM_CMD_OVERRIDE-}" != "" ]]; then
  read -ra STEAM_CMD_ARR <<<"$STEAM_CMD_OVERRIDE"
else
  STEAM_CMD_ARR=(steam -gamepadui)
fi

# Steam installation type (set during detection)
STEAM_TYPE=""  # "native" or "flatpak"

# Session mode: "kms" (bare VT) or "nested" (X11/Wayland compositor)
SESSION_MODE="kms"

# ---------------- config paths ----------------
CONFIG_DIR="$HOME/.config/smtty"
CONFIG_FILE="$CONFIG_DIR/config"          # Legacy single-config location
PROFILES_DIR="$CONFIG_DIR/profiles"       # Directory for named profiles
LAST_PROFILE_FILE="$CONFIG_DIR/last_profile"
AUDIO_STATE_FILE="$CONFIG_DIR/audio_state"

CURRENT_PROFILE=""

# ---------------- state ----------------
DRM_SHORT=""
DRM_NATIVE_MODE=""
NATIVE_W=0
NATIVE_H=0

GAME_W=0
GAME_H=0
STRETCH_FLAG="none"   # "none" | "stretch"

G_FPS=0               # gamescope -r (target display refresh, Hz; 0 = unlimited)
G_FPS_BG=0            # gamescope -o (unfocused refresh, Hz; 0 = disabled / omit -o)

# VRR / HDR / cursor flags
ADAPTIVE_SYNC=0          # 0/1 -> --adaptive-sync
ENABLE_GAMESCOPE_HDR=0   # 0/1 -> --hdr-enabled/ITM
GAMESCOPE_HDR_NITS=1000  # used with --hdr-itm-target-nits
FORCE_GRAB_CURSOR=0      # 0/1 -> --force-grab-cursor

# PipeWire debug control for gamescope
# "inherit" = do not set PIPEWIRE_DEBUG (respect system / environment)
# "0"       = errors only (quiet)
# "1"       = errors + warnings
# "2"       = info
# "3"       = verbose debug
PIPEWIRE_DEBUG_MODE="2"

# LD_PRELOAD handling for gamescope/Steam
# "inherit" = do not modify LD_PRELOAD
# "clear"   = export LD_PRELOAD="" before launching gamescope
LD_PRELOAD_MODE="clear"

# Temporary audio switching (PulseAudio / PipeWire via pactl)
AUDIO_SWITCH_ENABLED=0   # 0/1: switch default sink while gamescope runs
AUDIO_SINK_NAME=""       # sink name to use when AUDIO_SWITCH_ENABLED=1

# Optional hooks tied to the profile:
#   PRE_CMD  runs asynchronously before gamescope starts.
#   POST_CMD runs only when smtty tears down with "smtty -k".
PRE_CMD=""
POST_CMD=""

MISSING_CMDS=()
HAVE_CONFIG=0

# flags
FLAG_HELP=0
FLAG_NEW=0
FLAG_LAST=0
FLAG_PRINT=0
FLAG_KILL=0
FLAG_DETACH=0
FLAG_LAUNCH_OPTS=0    # -O: generate Steam launch options
FLAG_KILL_STEAM=0     # -S: kill Steam client before launching (no prompt)
FLAG_LIST_PROFILES=0  # -L: list available profiles
FLAG_DELETE_PROFILE=0 # -D: delete a profile
SELECTED_PROFILE=""   # -c <profile>: use specific profile

# ---------------- helpers ----------------
require_cmd() {
  local cmd=$1
  if ! command -v "$cmd" >/dev/null 2>&1; then
    MISSING_CMDS+=("$cmd")
  fi
}

prompt_select() {
  local prompt=$1
  shift
  local count=$#
  local i=1
  local opt
  for opt in "$@"; do
    printf '  [%d] %s\n' "$i" "$opt"
    i=$((i + 1))
  done
  local sel
  while :; do
    read -rp "$prompt " sel || exit 1
    if [[ ! "$sel" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( sel >= 1 && sel <= count )); then
      REPLY=$sel
      return 0
    fi
    echo "Out of range."
  done
}

prompt_select_default() {
  local prompt=$1
  local default_index=$2
  shift 2
  local count=$#
  local i=1
  local opt
  for opt in "$@"; do
    printf '  [%d] %s\n' "$i" "$opt"
    i=$((i + 1))
  done
  local sel
  while :; do
    read -rp "$prompt [$default_index]: " sel || exit 1
    if [[ -z "$sel" ]]; then
      sel=$default_index
    fi
    if [[ ! "$sel" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( sel >= 1 && sel <= count )); then
      REPLY=$sel
      return 0
    fi
    echo "Out of range."
  done
}

read_default() {
  local prompt=$1
  local def=$2
  local val
  read -rp "$prompt [$def]: " val || exit 1
  if [[ -z "$val" ]]; then
    printf '%s\n' "$def"
  else
    printf '%s\n' "$val"
  fi
}

print_help() {
  cat <<EOF
smtty - Steam Machine launcher (gamescope-only)

Usage:
  smtty [options]

Options:
  -h        Show this help and exit.
  -n        New interactive setup. Prompts for profile name to save.
  -l        Use last saved profile immediately (no questions).
            With -l, smtty never kills Steam unless you also pass -S.
  -c <name> Use specific configuration profile and launch immediately.
  -L        List all available configuration profiles.
  -D <name> Delete specified configuration profile.
  -p        Print saved config summary and exit.
  -k        Kill any running gamescope processes and exit.
            If the active profile defines a POST_CMD, it is run after audio restore.
  -d        Detach: start gamescope/Steam in the background and return immediately.
  -S        Kill any running Steam client before launching gamescope (no prompt).
  -O        Interactively generate ready-to-paste Steam per-game launch options and exit.

Environment:
  STEAM_CMD_OVERRIDE='steam -gamepadui'
      Override the Steam command used (default is auto-chosen native/flatpak).
  PIPEWIRE_DEBUG
      If smtty PipeWire mode is "inherit", this is passed through unchanged.
      Otherwise, smtty overrides it with the selected numeric level.
  LD_PRELOAD
      If smtty LD_PRELOAD mode is "inherit", this is passed through unchanged.
      If mode is "clear", smtty exports LD_PRELOAD="" before gamescope.

Config:
  $PROFILES_DIR/<profile_name>.conf
      Stores named configuration profiles with DRM output, resolution,
      stretch flag, gamescope display rate, unfocused background rate,
      VRR / HDR settings, PipeWire debug level, LD_PRELOAD handling,
      Steam type, optional audio sink switching, and optional pre/post commands.

      PRE_CMD  runs asynchronously before gamescope starts.
      POST_CMD runs only when the session is torn down via "smtty -k".

  $LAST_PROFILE_FILE
      Tracks the last used profile name for -l flag.

Examples:
  smtty -n                    # Create new profile (will prompt for name)
  smtty -c gaming             # Launch with 'gaming' profile
  smtty -c 4k-stretched       # Launch with '4k-stretched' profile
  smtty -L                    # List all available profiles
  smtty -D old-config         # Delete 'old-config' profile
  smtty -l                    # Use last profile immediately

Notes:
  - Can be run from a bare TTY (KMS mode) or from inside a compositor
    (Hyprland, Sway, KDE, GNOME, etc.). Resolution and scaling are always
    applied via gamescope runtime flags, not permanent display config writes.
  - Profile names can contain letters, numbers, hyphens, and underscores.
  - By default, smtty will ask whether to use last settings when
    a config exists, unless you explicitly pass -l or -c.
EOF
}

# Migrate legacy single config to default profile
migrate_legacy_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    return 0
  fi

  if [[ -d "$PROFILES_DIR" ]] && [[ -f "$PROFILES_DIR/default.conf" ]]; then
    return 0
  fi

  print_info "Migrating legacy config to 'default' profile..."
  mkdir -p "$PROFILES_DIR"
  cp "$CONFIG_FILE" "$PROFILES_DIR/default.conf"
  echo "default" >"$LAST_PROFILE_FILE"
  print_success "Migration complete. Old config preserved at: $CONFIG_FILE"
  echo
}

get_profile_path() {
  local profile_name=$1
  printf '%s/%s.conf' "$PROFILES_DIR" "$profile_name"
}

validate_profile_name() {
  local name=$1
  if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    print_error "Profile name can only contain letters, numbers, hyphens, and underscores."
    return 1
  fi
  if [[ ${#name} -gt 50 ]]; then
    print_error "Profile name too long (max 50 characters)."
    return 1
  fi
  return 0
}

list_profiles() {
  migrate_legacy_config

  if [[ ! -d "$PROFILES_DIR" ]]; then
    echo "No configuration profiles found."
    echo "Create one with: smtty -n"
    return 0
  fi

  local profiles=()
  local last_profile=""

  if [[ -f "$LAST_PROFILE_FILE" ]]; then
    last_profile=$(<"$LAST_PROFILE_FILE")
  fi

  while IFS= read -r -d '' profile_file; do
    local basename="${profile_file##*/}"
    local profile_name="${basename%.conf}"
    profiles+=("$profile_name")
  done < <(find "$PROFILES_DIR" -maxdepth 1 -name "*.conf" -print0 2>/dev/null | sort -z)

  if (( ${#profiles[@]} == 0 )); then
    echo "No configuration profiles found."
    echo "Create one with: smtty -n"
    return 0
  fi

  echo "Available configuration profiles:"
  echo
  local profile
  for profile in "${profiles[@]}"; do
    if [[ "$profile" == "$last_profile" ]]; then
      printf '  • %s %s(last used)%s\n' "$profile" "$GREEN" "$NC"
    else
      printf '  • %s\n' "$profile"
    fi
  done
  echo
  echo "Use with: smtty -c <profile_name>"
  echo "Delete with: smtty -D <profile_name>"
}

delete_profile() {
  local profile_name=$1

  if [[ -z "$profile_name" ]]; then
    print_error "Profile name required. Usage: smtty -D <profile_name>"
    exit 1
  fi

  local profile_path
  profile_path=$(get_profile_path "$profile_name")

  if [[ ! -f "$profile_path" ]]; then
    print_error "Profile '$profile_name' does not exist."
    echo "Available profiles:"
    list_profiles
    exit 1
  fi

  local ans
  read -rp "Delete profile '$profile_name'? [y/N]: " ans || exit 1
  case "$ans" in
    [yY])
      rm -f "$profile_path"
      print_success "Profile '$profile_name' deleted."

      # If this was the last-used profile, choose a new default if possible
      local last_profile=""
      if [[ -f "$LAST_PROFILE_FILE" ]]; then
        last_profile=$(<"$LAST_PROFILE_FILE")
      fi

      if [[ "$last_profile" == "$profile_name" ]]; then
        local fallback=""

        # Prefer a profile literally named "default" if it exists
        if [[ -f "$(get_profile_path "default")" ]]; then
          fallback="default"
        else
          # Otherwise pick the first remaining profile (if any)
          local pfile pbase pname
          while IFS= read -r -d '' pfile; do
            pbase="${pfile##*/}"
            pname="${pbase%.conf}"
            if [[ -z "$fallback" ]]; then
              fallback="$pname"
            fi
          done < <(find "$PROFILES_DIR" -maxdepth 1 -name "*.conf" -print0 2>/dev/null | sort -z)
        fi

        if [[ -n "$fallback" ]]; then
          echo "$fallback" >"$LAST_PROFILE_FILE"
          print_info "Last profile changed to '$fallback'."
        else
          # No profiles left at all
          rm -f "$LAST_PROFILE_FILE" 2>/dev/null || true
          print_info "No profiles remain. Next launch will run full setup."
        fi
      fi
      ;;
    *)
      echo "Cancelled."
      exit 0
      ;;
  esac
}

prompt_profile_name() {
  local default_name="default"
  local profile_name

  echo
  echo "Save this configuration as a named profile."
  echo "Examples: gaming, 4k-monitor, stretched-43, desktop-session"
  echo

  while :; do
    read -rp "Profile name [$default_name]: " profile_name || exit 1

    if [[ -z "$profile_name" ]]; then
      profile_name="$default_name"
    fi

    if ! validate_profile_name "$profile_name"; then
      continue
    fi

    local profile_path
    profile_path=$(get_profile_path "$profile_name")

    if [[ -f "$profile_path" ]]; then
      local ans
      read -rp "Profile '$profile_name' already exists. Overwrite? [y/N]: " ans || exit 1
      case "$ans" in
        [yY]) break ;;
        *) continue ;;
      esac
    else
      break
    fi
  done

  CURRENT_PROFILE="$profile_name"
  echo
  print_info "Will save as profile: $CURRENT_PROFILE"
  echo
}

select_profile_interactive() {
  local mode=${1:-use}

  migrate_legacy_config

  if [[ ! -d "$PROFILES_DIR" ]]; then
    return 1
  fi

  local profiles=()

  while IFS= read -r -d '' profile_file; do
    local basename="${profile_file##*/}"
    local profile_name="${basename%.conf}"
    profiles+=("$profile_name")
  done < <(find "$PROFILES_DIR" -maxdepth 1 -name "*.conf" -print0 2>/dev/null | sort -z)

  if (( ${#profiles[@]} == 0 )); then
    return 1
  fi

  if (( ${#profiles[@]} == 1 )); then
    CURRENT_PROFILE="${profiles[0]}"
    echo "Only one profile found: $CURRENT_PROFILE"
    if [[ "$mode" == "use" ]]; then
      echo "Using this profile."
    fi
    echo
    return 0
  fi

  echo "Available profiles:"
  local prompt
  if [[ "$mode" == "delete" ]]; then
    prompt="Select profile to delete:"
  else
    prompt="Select profile to use:"
  fi
  prompt_select "$prompt" "${profiles[@]}"
  CURRENT_PROFILE="${profiles[REPLY-1]}"
  echo
  return 0
}

audio_sink_display_name() {
  local name=$1

  if [[ -z "$name" ]]; then
    printf '%s\n' ""
    return 0
  fi

  if ! command -v pactl >/dev/null 2>&1; then
    printf '%s\n' "$name"
    return 0
  fi

  local desc
  desc=$(pactl list sinks 2>/dev/null | awk -v target="$name" '
    $1 == "Name:" {
      gsub("\r","")
      current = $2
    }
    current == target && $1 == "Description:" {
      $1 = ""
      sub(/^ +/, "")
      gsub("\r","")
      print
      exit
    }
    current == target && $1 == "device.description" && $2 == "=" {
      out = ""
      for (i = 3; i <= NF; ++i) {
        if (i > 3) out = out " "
        out = out $i
      }
      gsub("\r","", out)
      print out
      exit
    }
    current == target && $1 == "node.description" && $2 == "=" {
      out = ""
      for (i = 3; i <= NF; ++i) {
        if (i > 3) out = out " "
        out = out $i
      }
      gsub("\r","", out)
      print out
      exit
    }
  ')

  if [[ -n "$desc" ]]; then
    desc=${desc#\"}
    desc=${desc%\"}
    printf '%s\n' "$desc"
  else
    printf '%s\n' "$name"
  fi
}

print_config_summary() {
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config loaded"
    return
  fi

  local config_label="Loaded configuration"
  if [[ -n "$CURRENT_PROFILE" ]]; then
    config_label="Profile '$CURRENT_PROFILE'"
  fi

  local pre_display="${PRE_CMD:-}"
  local post_display="${POST_CMD:-}"
  if [[ -z "$pre_display" ]]; then
    pre_display="(none)"
  fi
  if [[ -z "$post_display" ]]; then
    post_display="(none)"
  fi

  echo "$config_label:"
  echo "  Steam type:               ${STEAM_TYPE:-native}"
  echo "  Output:                   $DRM_SHORT"
  echo "  Native mode:              $DRM_NATIVE_MODE"
  echo "  Game resolution:          ${GAME_W}x${GAME_H}"
  echo "  Stretch flag:             $STRETCH_FLAG"
  echo "  gamescope display rate:   $G_FPS Hz (0 = unlimited, -r)"
  echo "  gamescope unfocused rate: $G_FPS_BG Hz (0 = disabled, -o omitted)"
  echo "  gamescope adaptive-sync:  $ADAPTIVE_SYNC"
  echo "  gamescope HDR enabled:    $ENABLE_GAMESCOPE_HDR"
  echo "  gamescope HDR nits:       $GAMESCOPE_HDR_NITS"
  echo "  gamescope force grab:     $FORCE_GRAB_CURSOR"
  echo "  PipeWire debug mode:      $PIPEWIRE_DEBUG_MODE (inherit or 0-3)"
  echo "  LD_PRELOAD mode:          ${LD_PRELOAD_MODE:-clear} (inherit or clear)"
  echo "  Audio switch enabled:     $AUDIO_SWITCH_ENABLED"
  if (( AUDIO_SWITCH_ENABLED )); then
    local sink_desc
    sink_desc=$(audio_sink_display_name "$AUDIO_SINK_NAME")
    echo "  Audio sink name:          ${AUDIO_SINK_NAME:-"(unset)"}"
    echo "  Audio sink description:   ${sink_desc:-"(unresolved)"}"
  fi
  echo "  Pre-command (async):      $pre_display"
  echo "  Post-command (smtty -k):  $post_display"
}

save_config() {
  mkdir -p "$PROFILES_DIR"

  if [[ -z "$CURRENT_PROFILE" ]]; then
    prompt_profile_name
  fi

  local profile_path
  profile_path=$(get_profile_path "$CURRENT_PROFILE")

  cat >"$profile_path" <<EOF
DRM_SHORT=$DRM_SHORT
DRM_NATIVE_MODE=$DRM_NATIVE_MODE
NATIVE_W=$NATIVE_W
NATIVE_H=$NATIVE_H
GAME_W=$GAME_W
GAME_H=$GAME_H
STRETCH_FLAG=$STRETCH_FLAG
G_FPS=$G_FPS
G_FPS_BG=$G_FPS_BG
STEAM_TYPE=$STEAM_TYPE
ADAPTIVE_SYNC=$ADAPTIVE_SYNC
ENABLE_GAMESCOPE_HDR=$ENABLE_GAMESCOPE_HDR
GAMESCOPE_HDR_NITS=$GAMESCOPE_HDR_NITS
FORCE_GRAB_CURSOR=$FORCE_GRAB_CURSOR
PIPEWIRE_DEBUG_MODE=$PIPEWIRE_DEBUG_MODE
LD_PRELOAD_MODE=$LD_PRELOAD_MODE
AUDIO_SWITCH_ENABLED=$AUDIO_SWITCH_ENABLED
AUDIO_SINK_NAME=$AUDIO_SINK_NAME
PRE_CMD=$(printf '%q' "$PRE_CMD")
POST_CMD=$(printf '%q' "$POST_CMD")
EOF

  echo "$CURRENT_PROFILE" >"$LAST_PROFILE_FILE"

  print_success "Configuration saved as profile: $CURRENT_PROFILE"
}

load_profile_file() {
  local profile_path=$1

  if [[ ! -r "$profile_path" ]] || [[ ! -s "$profile_path" ]]; then
    print_warn "Profile file exists but is not readable or empty: $profile_path"
    HAVE_CONFIG=0
    return 1
  fi

  # shellcheck source=/dev/null
  . "$profile_path"
  HAVE_CONFIG=1

  PIPEWIRE_DEBUG_MODE=${PIPEWIRE_DEBUG_MODE:-2}
  FORCE_GRAB_CURSOR=${FORCE_GRAB_CURSOR:-0}
  LD_PRELOAD_MODE=${LD_PRELOAD_MODE:-clear}
  G_FPS_BG=${G_FPS_BG:-0}
  AUDIO_SWITCH_ENABLED=${AUDIO_SWITCH_ENABLED:-0}
  AUDIO_SINK_NAME=${AUDIO_SINK_NAME:-""}
  PRE_CMD=${PRE_CMD:-""}
  POST_CMD=${POST_CMD:-""}

  return 0
}

load_profile_by_name() {
  local name=$1
  migrate_legacy_config

  if [[ -z "$name" ]]; then
    HAVE_CONFIG=0
    return 1
  fi

  local profile_path
  profile_path=$(get_profile_path "$name")

  if [[ ! -f "$profile_path" ]]; then
    print_error "Profile '$name' not found at: $profile_path"
    echo "Available profiles:"
    list_profiles
    exit 1
  fi

  load_profile_file "$profile_path" || exit 1

  CURRENT_PROFILE="$name"
  mkdir -p "$CONFIG_DIR"
  echo "$name" >"$LAST_PROFILE_FILE"
}

load_config_default() {
  migrate_legacy_config
  HAVE_CONFIG=0

  if [[ ! -f "$LAST_PROFILE_FILE" ]]; then
    return 0
  fi

  local last_profile
  last_profile=$(<"$LAST_PROFILE_FILE")
  if [[ -z "$last_profile" ]]; then
    return 0
  fi

  local profile_path
  profile_path=$(get_profile_path "$last_profile")

  if [[ ! -f "$profile_path" ]]; then
    print_warn "Last profile '$last_profile' no longer exists."
    CURRENT_PROFILE=""
    HAVE_CONFIG=0
    return 0
  fi

  CURRENT_PROFILE="$last_profile"
  load_profile_file "$profile_path" || return 0
}

detect_session_mode() {
  if [[ -n "${WAYLAND_DISPLAY-}" || -n "${DISPLAY-}" ]]; then
    SESSION_MODE="nested"
  else
    SESSION_MODE="kms"
  fi
}

# ---------------- output / resolution selection ----------------
choose_drm_output() {
  echo "Detected *connected* outputs:"
  echo

  local entries=()
  local idx=1
  local status_path status dir modes_path short native_line

  for status_path in /sys/class/drm/card*-*/status; do
    [[ -f "$status_path" ]] || continue
    status=$(<"$status_path")
    [[ "$status" == "connected" ]] || continue

    dir=${status_path%/status}
    modes_path="$dir/modes"
    [[ -f "$modes_path" ]] || continue

    short=${dir##*/}
    short=${short#card*-}

    native_line="unknown"
    local max_area=0
    local mline mw mh area
    while IFS= read -r mline; do
      [[ -z "$mline" ]] && continue
      if [[ "$mline" =~ ([0-9]+)x([0-9]+) ]]; then
        mw=${BASH_REMATCH[1]}
        mh=${BASH_REMATCH[2]}
        area=$(( mw * mh ))
        if (( area > max_area )); then
          max_area=$area
          native_line="$mline"
        fi
      fi
    done <"$modes_path"

    entries+=("$short:$native_line")
    printf '  [%d] %s (native: %s)\n' "$idx" "$short" "$native_line"
    idx=$((idx + 1))
  done

  if ((${#entries[@]} == 0)); then
    print_error "No *connected* DRM outputs found under /sys/class/drm."
    exit 1
  fi

  local choice
  while :; do
    read -rp "Select output [1-${#entries[@]}]: " choice || exit 1
    if [[ ! "$choice" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( choice >= 1 && choice <= ${#entries[@]} )); then
      break
    fi
    echo "Out of range."
  done

  local chosen=${entries[choice-1]}
  DRM_SHORT=${chosen%%:*}
  DRM_NATIVE_MODE=${chosen#*:}

  local base=${DRM_NATIVE_MODE%%@*}
  if [[ "$base" =~ ^([0-9]+)x([0-9]+)$ ]]; then
    NATIVE_W=${BASH_REMATCH[1]}
    NATIVE_H=${BASH_REMATCH[2]}
  else
    print_error "Failed to parse native mode \"$DRM_NATIVE_MODE\"; expected WxH[@Hz]."
    exit 1
  fi

  echo
  echo "Using output: $DRM_SHORT (native ${NATIVE_W}x${NATIVE_H})"
  echo "Session mode: $SESSION_MODE (kms = bare VT, nested = under compositor)"
  echo
  if [[ "$SESSION_MODE" == "nested" ]]; then
    echo "Note: running under a compositor. gamescope will be nested as a window"
    echo "      or fullscreen surface. Physical monitor resolution is not changed,"
    echo "      but gamescope still controls internal and outer resolutions/scaling."
    echo
  fi
}

choose_resolution_profile() {
  GAME_W=$NATIVE_W
  GAME_H=$NATIVE_H
  STRETCH_FLAG="none"

  local custom_profile=0

  if [[ $NATIVE_W -eq 1920 && $NATIVE_H -eq 1080 ]]; then
    echo "Resolution profile for 1080p 16:9:"
    prompt_select_default "Choose profile" 1 \
      "Native 1920x1080" \
      "1352x1080 (4:3 base)" \
      "1680x1050 (16:10 base)" \
      "Custom"
    case $REPLY in
      1) GAME_W=1920; GAME_H=1080 ;;
      2) GAME_W=1352; GAME_H=1080 ;;
      3) GAME_W=1680; GAME_H=1050 ;;
      4) custom_profile=1 ;;
    esac
  elif [[ $NATIVE_W -eq 2560 && $NATIVE_H -eq 1440 ]]; then
    echo "Resolution profile for 1440p 16:9:"
    prompt_select_default "Choose profile" 1 \
      "Native 2560x1440" \
      "1920x1440 (4:3 base)" \
      "1920x1200 (16:10 base)" \
      "Custom"
    case $REPLY in
      1) GAME_W=2560; GAME_H=1440 ;;
      2) GAME_W=1920; GAME_H=1440 ;;
      3) GAME_W=1920; GAME_H=1200 ;;
      4) custom_profile=1 ;;
    esac
  elif [[ $NATIVE_W -eq 3840 && $NATIVE_H -eq 2160 ]]; then
    echo "Resolution profile for 4K 16:9:"
    prompt_select_default "Choose profile" 1 \
      "Native 3840x2160" \
      "2560x1440 (downscale base)" \
      "1920x1440 (4:3 base)" \
      "1920x1200 (16:10 base)" \
      "Custom"
    case $REPLY in
      1) GAME_W=3840; GAME_H=2160 ;;
      2) GAME_W=2560; GAME_H=1440 ;;
      3) GAME_W=1920; GAME_H=1440 ;;
      4) GAME_W=1920; GAME_H=1200 ;;
      5) custom_profile=1 ;;
    esac
  fi

  echo
  echo "Scaling / stretch mode for outer ${NATIVE_W}x${NATIVE_H}:"
  prompt_select_default "How should gamescope scale the game image" 1 \
    "No stretch (preserve aspect, letterbox/pillarbox)" \
    "Stretch to fill (gamescope -S stretch)"
  case $REPLY in
    1) STRETCH_FLAG="none" ;;
    2) STRETCH_FLAG="stretch" ;;
    *) STRETCH_FLAG="none" ;;
  esac

  echo
  local prompt_label
  if (( custom_profile )); then
    prompt_label="Custom GAME resolution WxH (gamescope -w/-h)"
  else
    prompt_label="Game resolution WxH (gamescope -w/-h)"
  fi

  local default_str="${GAME_W}x${GAME_H}"
  local resp
  resp=$(read_default "$prompt_label" "$default_str")
  if [[ "$resp" =~ ^([0-9]+)x([0-9]+)$ ]]; then
    GAME_W=${BASH_REMATCH[1]}
    GAME_H=${BASH_REMATCH[2]}
  else
    echo "Invalid format; keeping $default_str."
  fi

  echo
  echo "Game resolution: ${GAME_W}x${GAME_H}"
  echo "Stretch flag:    ${STRETCH_FLAG}"
  echo
}

choose_gamescope_rate() {
  local val
  val=$(read_default "Target display refresh for gamescope (-r, Hz, 0 = unlimited)" "$G_FPS")
  if [[ ! "$val" =~ ^[0-9]+$ ]]; then
    echo "Invalid value; using 0."
    val=0
  fi
  G_FPS=$val

  echo
  local raw
  read -rp "Nested unfocused refresh (-o, Hz, empty = disabled): " raw || exit 1
  if [[ -z "$raw" ]]; then
    G_FPS_BG=0
  elif [[ "$raw" =~ ^[0-9]+$ ]]; then
    G_FPS_BG=$raw
  else
    echo "Invalid value; disabling -o."
    G_FPS_BG=0
  fi
  echo
}

choose_vrr_hdr_and_steamos() {
  echo "Optional gamescope features:"

  local vrr
  while :; do
    vrr=$(read_default "Enable gamescope adaptive sync / VRR? (0 = no, 1 = yes)" "$ADAPTIVE_SYNC")
    case "$vrr" in
      0|1)
        ADAPTIVE_SYNC=$vrr
        break
        ;;
      *)
        echo "Enter 0 or 1."
        ;;
    esac
  done

  local hdr
  while :; do
    hdr=$(read_default "Enable gamescope HDR output? (0 = no, 1 = yes)" "$ENABLE_GAMESCOPE_HDR")
    case "$hdr" in
      0|1)
        break
        ;;
      *)
        echo "Enter 0 or 1."
        ;;
    esac
  done

  if [[ "$hdr" == "1" ]]; then
    ENABLE_GAMESCOPE_HDR=1
    local nits
    nits=$(read_default "HDR ITM target nits (gamescope --hdr-itm-target-nits)" "$GAMESCOPE_HDR_NITS")
    if [[ "$nits" =~ ^[0-9]+$ ]]; then
      GAMESCOPE_HDR_NITS=$nits
    else
      echo "Invalid nits value; keeping $GAMESCOPE_HDR_NITS."
    fi
  else
    ENABLE_GAMESCOPE_HDR=0
  fi

  echo
  echo "Cursor grab:"
  echo "  Mostly useful on bare TTY (KMS). In nested sessions it can make"
  echo "  mouse input worse if games and overlays already manage grabs."

  local fg
  while :; do
    fg=$(read_default "Force gamescope cursor grab? (0 = no, 1 = yes)" "$FORCE_GRAB_CURSOR")
    case "$fg" in
      0|1)
        FORCE_GRAB_CURSOR=$fg
        break
        ;;
      *)
        echo "Enter 0 or 1."
        ;;
    esac
  done

  echo
}

choose_pipewire_debug() {
  echo "PipeWire / gamescope log verbosity:"
  echo "  This controls PIPEWIRE_DEBUG for the gamescope process only."
  echo "  Lower values reduce spam like 'pipewire: warning: out of buffers'."
  echo
  echo "  [1] Inherit system default (do not set PIPEWIRE_DEBUG)"
  echo "  [2] Quiet: errors only [PIPEWIRE_DEBUG=0]"
  echo "  [3] Errors + warnings [PIPEWIRE_DEBUG=1]"
  echo "  [4] Info (more detail) [PIPEWIRE_DEBUG=2]"
  echo "  [5] Verbose debug [PIPEWIRE_DEBUG=3]"

  local default_choice
  case "$PIPEWIRE_DEBUG_MODE" in
    inherit) default_choice=1 ;;
    0)       default_choice=2 ;;
    1)       default_choice=3 ;;
    2)       default_choice=4 ;;
    3)       default_choice=5 ;;
    *)       default_choice=4 ;;
  esac

  local sel
  sel=$(read_default "Choose PipeWire debug level (1-5)" "$default_choice")

  if [[ ! "$sel" =~ ^[1-5]$ ]]; then
    echo "Invalid selection; keeping current PipeWire debug mode: $PIPEWIRE_DEBUG_MODE"
  else
    case "$sel" in
      1) PIPEWIRE_DEBUG_MODE="inherit" ;;
      2) PIPEWIRE_DEBUG_MODE="0" ;;
      3) PIPEWIRE_DEBUG_MODE="1" ;;
      4) PIPEWIRE_DEBUG_MODE="2" ;;
      5) PIPEWIRE_DEBUG_MODE="3" ;;
    esac
  fi

  echo
  echo "PipeWire debug mode set to: $PIPEWIRE_DEBUG_MODE"
  echo "  inherit  = smtty leaves PIPEWIRE_DEBUG alone"
  echo "  0        = only errors (very quiet)"
  echo "  1        = errors + warnings"
  echo "  2        = info"
  echo "  3        = verbose debug"
  echo
}

choose_ld_preload_mode() {
  echo "LD_PRELOAD handling for gamescope / Steam:"
  echo "  Clearing LD_PRELOAD avoids inherited overlays/shims (MangoHud, vkBasalt,"
  echo "  etc.) from injecting into gamescope or the game."
  echo
  echo "  [1] Inherit current LD_PRELOAD (do nothing)"
  echo "  [2] Clear LD_PRELOAD for gamescope and Steam"

  local default_choice
  case "$LD_PRELOAD_MODE" in
    inherit) default_choice=1 ;;
    clear)   default_choice=2 ;;
    *)       default_choice=2 ;;
  esac

  local sel
  sel=$(read_default "Choose LD_PRELOAD mode (1-2)" "$default_choice")

  case "$sel" in
    1) LD_PRELOAD_MODE="inherit" ;;
    2) LD_PRELOAD_MODE="clear" ;;
    *)
      echo "Invalid selection; keeping current LD_PRELOAD mode: $LD_PRELOAD_MODE"
      ;;
  esac

  echo
  echo "LD_PRELOAD mode set to: $LD_PRELOAD_MODE"
  echo "  inherit = pass through existing LD_PRELOAD"
  echo "  clear   = export LD_PRELOAD=\"\" before gamescope"
  echo
}

choose_audio_switch() {
  echo "Temporary audio output switching (PulseAudio / PipeWire via pactl):"

  if ! command -v pactl >/dev/null 2>&1; then
    echo "  pactl not found; audio device switching will be disabled."
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return
  fi

  local en
  en=$(read_default "Enable automatic audio output switch while gamescope is running? (0 = no, 1 = yes)" 0)

  if [[ "$en" == "1" ]]; then
    AUDIO_SWITCH_ENABLED=1
  else
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return
  fi

  mapfile -t sink_lines < <(pactl list short sinks 2>/dev/null || true)

  if ((${#sink_lines[@]} == 0)); then
    echo "  No sinks found; disabling audio switching."
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return
  fi

  local -a sink_names=()
  local -a sink_descs=()
  local line name idx

  for line in "${sink_lines[@]}"; do
    read -r idx name _ <<<"$line"
    if [[ -z "$name" ]]; then
      continue
    fi
    sink_names+=("$name")
    sink_descs+=("$(audio_sink_display_name "$name")")
  done

  if ((${#sink_names[@]} == 0)); then
    echo "  No valid sinks parsed; disabling audio switching."
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return
  fi

  echo
  echo "Available audio outputs (PulseAudio / PipeWire sinks):"
  local i
  for ((i = 0; i < ${#sink_names[@]}; i++)); do
    local desc="${sink_descs[i]}"
    local raw="${sink_names[i]}"
    if [[ -n "$desc" && "$desc" != "$raw" ]]; then
      printf '  [%d] %s (%s)\n' "$((i + 1))" "$desc" "$raw"
    else
      printf '  [%d] %s\n' "$((i + 1))" "$raw"
    fi
  done

  local choice
  while :; do
    read -rp "Choose sink to use while gamescope is running [1-${#sink_names[@]}]: " choice || exit 1
    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#sink_names[@]} )); then
      break
    fi
    echo "Enter a number between 1 and ${#sink_names[@]}."
  done

  AUDIO_SINK_NAME=${sink_names[choice-1]}

  echo
  echo "Audio switcher will use:"
  echo "  Description: ${sink_descs[choice-1]}"
  echo "  Name:        ${AUDIO_SINK_NAME}"
  echo
}

choose_pre_post_commands() {
  echo "Optional pre / post shell commands for this profile:"
  echo "  Pre-command runs asynchronously before gamescope starts."
  echo "  Post-command runs only when you tear down the session via 'smtty -k'."
  echo "  Leave empty to skip."
  echo

  local pre
  pre=$(read_default "Pre-command (empty = none)" "${PRE_CMD:-}")
  PRE_CMD="$pre"

  local post
  post=$(read_default "Post-command for smtty -k (empty = none)" "${POST_CMD:-}")
  POST_CMD="$post"

  echo
}

get_default_sink() {
  local current=""
  current=$(pactl get-default-sink 2>/dev/null || true)
  if [[ -z "$current" ]]; then
    current=$(pactl info 2>/dev/null | awk -F': ' '/Default Sink:/ {print $2; exit}')
  fi
  printf '%s\n' "$current"
}

audio_switch_can_run() {
  if (( AUDIO_SWITCH_ENABLED != 1 )); then
    return 1
  fi
  if [[ -z "$AUDIO_SINK_NAME" ]]; then
    return 1
  fi
  if ! command -v pactl >/dev/null 2>&1; then
    return 1
  fi
  return 0
}

audio_switch_start_for_pid() {
  local pid=$1

  if ! audio_switch_can_run; then
    return 0
  fi

  local original
  original=$(get_default_sink)
  if [[ -z "$original" ]]; then
    print_warn "Could not determine current default sink; skipping audio switch."
    return 0
  fi

  if [[ "$original" == "$AUDIO_SINK_NAME" ]]; then
    return 0
  fi

  if ! pactl list short sinks 2>/dev/null | awk '{print $2}' | grep -qx "$AUDIO_SINK_NAME"; then
    print_warn "Configured audio sink '$AUDIO_SINK_NAME' not found; skipping audio switch."
    return 0
  fi

  print_info "Switching default audio sink: $original -> $AUDIO_SINK_NAME"
  if ! pactl set-default-sink "$AUDIO_SINK_NAME" 2>/dev/null; then
    print_warn "Failed to switch default sink; leaving audio unchanged."
    return 0
  fi

  mkdir -p "$CONFIG_DIR"
  cat >"$AUDIO_STATE_FILE" <<EOF
AUDIO_ACTIVE=1
AUDIO_ORIGINAL_SINK=$original
AUDIO_TARGET_SINK=$AUDIO_SINK_NAME
EOF

  (
    trap 'pactl set-default-sink "$original" >/dev/null 2>&1 || true; rm -f "$AUDIO_STATE_FILE"' EXIT TERM INT

    while kill -0 "$pid" 2>/dev/null; do
      sleep 1
    done
    print_info "Restoring default audio sink to $original"
    pactl set-default-sink "$original" >/dev/null 2>&1 || true
    rm -f "$AUDIO_STATE_FILE"
  ) &

  disown 2>/dev/null || true
}

audio_restore_from_state() {
  if ! command -v pactl >/dev/null 2>&1; then
    return 0
  fi

  if [[ ! -f "$AUDIO_STATE_FILE" ]]; then
    return 0
  fi

  if [[ ! -r "$AUDIO_STATE_FILE" ]] || [[ ! -s "$AUDIO_STATE_FILE" ]]; then
    print_warn "Audio state file exists but is not readable or empty"
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  # shellcheck source=/dev/null
  . "$AUDIO_STATE_FILE"

  local original="${AUDIO_ORIGINAL_SINK:-}"
  local target="${AUDIO_TARGET_SINK:-}"

  if [[ -z "$original" || -z "$target" ]]; then
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  local current
  current=$(get_default_sink)
  if [[ -z "$current" ]]; then
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  if [[ "$current" != "$target" ]]; then
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  print_info "Restoring default audio sink to $original (via smtty -k)"
  pactl set-default-sink "$original" >/dev/null 2>&1 || true
  rm -f "$AUDIO_STATE_FILE"
}

run_pre_hook() {
  if [[ -z "${PRE_CMD:-}" ]]; then
    return 0
  fi

  print_info "Running pre-command (async)..."
  # Run asynchronously so long-lived commands (like firefox) don't block gamescope.
  sh -c "$PRE_CMD" &
  disown 2>/dev/null || true
}

run_post_hook() {
  if [[ -n "${POST_CMD:-}" ]]; then
    print_info "Running post-command (smtty -k)..."
    if ! sh -c "$POST_CMD"; then
      print_warn "Post-command failed."
    fi
  fi
}

print_steam_launch_options() {
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config; run 'smtty -n -O' first."
    exit 1
  fi

  echo "Steam per-game launch options generator"
  if [[ -n "$CURRENT_PROFILE" ]]; then
    echo "Using profile: $CURRENT_PROFILE"
  fi
  echo

  echo "Enter your current Steam launch options for this game."
  echo "Example: gamemoderun %command% -novid +fps_max 0 -high -dx12"
  read -rp "Current launch options (empty = just %command%): " CURRENT_LAUNCH_OPTS || exit 1

  if [[ -z "$CURRENT_LAUNCH_OPTS" ]]; then
    CURRENT_LAUNCH_OPTS='%command%'
  else
    if [[ "$CURRENT_LAUNCH_OPTS" != *"%command%"* ]]; then
      echo "Note: your launch options did not contain %command%; appending at the end."
      CURRENT_LAUNCH_OPTS="$CURRENT_LAUNCH_OPTS %command%"
    fi
  fi

  echo

  local use_flatpak_prefix=0
  local ans

  if [[ "${STEAM_TYPE:-native}" == "flatpak" ]]; then
    echo "smtty config detected Steam Flatpak."
    read -rp "Prefix with 'flatpak-spawn --host' for this game? [Y/n]: " ans || exit 1
    case "$ans" in
      [nN]*) use_flatpak_prefix=0 ;;
      *)     use_flatpak_prefix=1 ;;
    esac
  else
    read -rp "Is this game using Steam Flatpak? [y/N]: " ans || exit 1
    case "$ans" in
      [yY]*) use_flatpak_prefix=1 ;;
      *)     use_flatpak_prefix=0 ;;
    esac
  fi

  echo

  local use_steam_integration=0
  echo "Steam overlay / integration mode for this game:"
  prompt_select "Choose integration mode:" \
    "No special Steam integration (no -e; more compatible, overlay may be weaker)" \
    "Steam integration (-e; tighter overlay wiring, can break some setups)"
  case "$REPLY" in
    2) use_steam_integration=1 ;;
    *) use_steam_integration=0 ;;
  esac

  echo

  detect_session_mode

  local args=()
  args+=(-f)
  args+=(-W "$NATIVE_W" -H "$NATIVE_H")
  args+=(-w "$GAME_W" -h "$GAME_H")

  if [[ "$SESSION_MODE" == "kms" && -n "$DRM_SHORT" ]]; then
    args+=(-O "$DRM_SHORT")
  fi

  if (( G_FPS > 0 )); then
    args+=(-r "$G_FPS")
  fi

  if (( G_FPS_BG > 0 )); then
    args+=(-o "$G_FPS_BG")
  fi

  if [[ "$STRETCH_FLAG" == "stretch" ]]; then
    args+=(-S stretch)
  fi

  if (( ADAPTIVE_SYNC == 1 )); then
    args+=(--adaptive-sync)
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )); then
    args+=(--hdr-enabled --hdr-itm-enable --hdr-itm-target-nits "$GAMESCOPE_HDR_NITS")
  fi

  if (( FORCE_GRAB_CURSOR == 1 )); then
    args+=(--force-grab-cursor)
  fi

  local env_prefix=""
  if [[ "${PIPEWIRE_DEBUG_MODE:-2}" != "inherit" ]]; then
    env_prefix+="PIPEWIRE_DEBUG=$PIPEWIRE_DEBUG_MODE "
  fi
  if [[ "${LD_PRELOAD_MODE:-clear}" == "clear" ]]; then
    env_prefix+='LD_PRELOAD="" '
  fi

  echo "Generated Steam launch options (nested gamescope, no Gamepad UI):"
  echo

  printf '%s' "$env_prefix"
  if (( use_flatpak_prefix )); then
    printf 'flatpak-spawn --host '
  fi
  printf 'gamescope'
  if (( use_steam_integration )); then
    printf ' -e'
  fi
  printf ' %q' "${args[@]}"
  printf ' -- %s\n' "$CURRENT_LAUNCH_OPTS"

  echo
  echo "Paste the above line into this game's Steam \"Launch Options\"."
}

# ---------------- Steam installation detection ----------------
detect_steam_installations() {
  local available=()
  local have_native=0
  local have_flatpak=0

  if command -v steam >/dev/null 2>&1; then
    available+=("Native Steam (steam)")
    have_native=1
  fi

  if command -v flatpak >/dev/null 2>&1 && \
     flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
    available+=("Steam Flatpak (com.valvesoftware.Steam)")
    have_flatpak=1
  fi

  if (( ${#available[@]} == 0 )); then
    print_error "No Steam installation found."
    echo "Please install Steam (native) or Steam Flatpak."
    exit 1
  fi

  if (( ${#available[@]} == 1 )); then
    if (( have_native )); then
      STEAM_TYPE="native"
      print_info "Detected: Native Steam"
    elif (( have_flatpak )); then
      STEAM_TYPE="flatpak"
      print_info "Detected: Steam Flatpak"
    else
      print_error "Internal error: Unknown Steam type despite one available."
      exit 1
    fi
    echo
    return
  fi

  echo "Multiple Steam installations detected:"
  prompt_select "Choose Steam installation:" "${available[@]}"

  if (( REPLY == 1 )); then
    STEAM_TYPE="native"
  else
    STEAM_TYPE="flatpak"
  fi

  echo
  echo "Using: ${available[REPLY-1]}"
  echo
}

configure_steam_command() {
  if [[ -n "${STEAM_CMD_OVERRIDE-}" ]]; then
    return
  fi

  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    STEAM_CMD_ARR=(flatpak run com.valvesoftware.Steam -gamepadui)
  else
    STEAM_CMD_ARR=(steam -gamepadui)
  fi
}

# ---------------- gamescope deps ----------------
check_deps() {
  MISSING_CMDS=()
  require_cmd gamescope

  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    require_cmd flatpak
    if ! flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
      print_error "Steam Flatpak (com.valvesoftware.Steam) is not installed."
      exit 1
    fi
  else
    require_cmd steam
  fi

  if ((${#MISSING_CMDS[@]} > 0)); then
    print_error "Missing required commands:"
    printf '  - %s\n' "${MISSING_CMDS[@]}"
    echo
    echo "Install the missing utilities with your package manager."
    exit 1
  fi
}

steam_is_running() {
  pgrep -x steam >/dev/null 2>&1
}

kill_steam_client() {
  if ! pgrep -x steam >/dev/null 2>&1; then
    echo "No Steam client processes found."
    return 0
  fi

  echo "Stopping Steam client..."
  pkill steam >/dev/null 2>&1 || true

  local i
  for ((i = 0; i < 40; i++)); do
    if ! pgrep -x steam >/dev/null 2>&1; then
      print_success "Steam client stopped."
      return 0
    fi
    sleep 0.25
  done

  print_error "Steam still appears to be running after waiting ~10 seconds."
  echo "Aborting smtty launch to avoid a broken gamescope start."
  exit 1
}

handle_running_steam_before_launch() {
  if ! steam_is_running; then
    return 0
  fi

  if (( FLAG_KILL_STEAM )); then
    kill_steam_client
    return 0
  fi

  if (( FLAG_LAST )) || [[ -n "$SELECTED_PROFILE" ]]; then
    return 0
  fi

  echo "Steam client is currently running."
  echo "There can only be one Steam instance at a time."
  echo "To launch Steam inside gamescope, smtty needs to stop the existing"
  echo "desktop Steam process and then relaunch Steam Gamepad UI in gamescope."
  local ans
  read -rp "Kill desktop Steam and relaunch it inside gamescope now? [y/N]: " ans || exit 1
  case "$ans" in
    [yY])
      kill_steam_client
      ;;
    *)
      echo "Leaving existing Steam session running. Aborting smtty launch to avoid a broken gamescope start."
      exit 1
      ;;
  esac
}

launch_vanilla_gamescope() {
  local inner_cmd=("$@")

  local args=()
  args+=(-f -e)
  args+=(-W "$NATIVE_W" -H "$NATIVE_H")
  args+=(-w "$GAME_W" -h "$GAME_H")

  if [[ "$SESSION_MODE" == "kms" && -n "$DRM_SHORT" ]]; then
    args+=(-O "$DRM_SHORT")
  fi

  if (( G_FPS > 0 )); then
    args+=(-r "$G_FPS")
  fi

  if (( G_FPS_BG > 0 )); then
    args+=(-o "$G_FPS_BG")
  fi

  if [[ "$STRETCH_FLAG" == "stretch" ]]; then
    args+=(-S stretch)
  fi

  if (( ADAPTIVE_SYNC == 1 )); then
    args+=(--adaptive-sync)
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )); then
    args+=(--hdr-enabled --hdr-itm-enable --hdr-itm-target-nits "$GAMESCOPE_HDR_NITS")
  fi

  if (( FORCE_GRAB_CURSOR == 1 )); then
    args+=(--force-grab-cursor)
  fi

  echo "Command:"
  printf 'gamescope'
  printf ' %q' "${args[@]}"
  printf ' --'
  printf ' %q' "${inner_cmd[@]}"
  printf '\n\n'

  run_pre_hook

  if [[ "${PIPEWIRE_DEBUG_MODE:-2}" != "inherit" ]]; then
    export PIPEWIRE_DEBUG="$PIPEWIRE_DEBUG_MODE"
  fi

  if [[ "${LD_PRELOAD_MODE:-clear}" == "clear" ]]; then
    export LD_PRELOAD=""
  fi

  if (( FLAG_DETACH )); then
    if command -v setsid >/dev/null 2>&1; then
      setsid gamescope "${args[@]}" -- "${inner_cmd[@]}" >/dev/null 2>&1 &
    else
      gamescope "${args[@]}" -- "${inner_cmd[@]}" >/dev/null 2>&1 &
    fi
    local gspid=$!
    audio_switch_start_for_pid "$gspid"
    print_success "gamescope started in detached mode with PID $gspid."
    echo "Use 'smtty -k' to kill any running gamescope processes."
    exit 0
  else
    audio_switch_start_for_pid "$$"
    exec gamescope "${args[@]}" -- "${inner_cmd[@]}"
  fi
}

launch_gamescope_session() {
  configure_steam_command
  check_deps

  local inner_cmd=()
  local inner_label="Steam Gamepad UI (Big Picture)"

  inner_cmd=("${STEAM_CMD_ARR[@]}")

  echo
  echo "Launching gamescope:"
  if [[ -n "$CURRENT_PROFILE" ]]; then
    echo "  Profile:               $CURRENT_PROFILE"
  fi
  echo "  Session mode:          $SESSION_MODE (kms = bare VT, nested = under compositor)"
  echo "  Steam type:            ${STEAM_TYPE:-native}"
  echo "  DRM output:            $DRM_SHORT"
  echo "  Outer (panel/native):  ${NATIVE_W}x${NATIVE_H}"
  echo "  Inner (game):          ${GAME_W}x${GAME_H}"
  echo "  Stretch mode:          ${STRETCH_FLAG}"
  echo "  Target refresh:        ${G_FPS} Hz (gamescope -r, 0 = unlimited)"
  echo "  Unfocused refresh:     ${G_FPS_BG} Hz (gamescope -o, 0 = disabled / omitted)"
  echo "  Adaptive sync (VRR):   ${ADAPTIVE_SYNC}"
  echo "  HDR enabled:           ${ENABLE_GAMESCOPE_HDR}"
  echo "  HDR ITM target nits:   ${GAMESCOPE_HDR_NITS}"
  echo "  Force cursor grab:     ${FORCE_GRAB_CURSOR}"
  echo "  PipeWire debug mode:   ${PIPEWIRE_DEBUG_MODE}"
  echo "  LD_PRELOAD mode:       ${LD_PRELOAD_MODE:-clear}"
  echo "  Audio switch enabled:  ${AUDIO_SWITCH_ENABLED}"
  if (( AUDIO_SWITCH_ENABLED )); then
    local sink_desc
    sink_desc=$(audio_sink_display_name "$AUDIO_SINK_NAME")
    echo "  Audio sink name:       ${AUDIO_SINK_NAME:-"(unset)"}"
    echo "  Audio sink desc:       ${sink_desc:-"(unresolved)"}"
  fi
  echo "  Inner payload:         $inner_label"
  echo "  Detach mode:           ${FLAG_DETACH}"
  echo

  launch_vanilla_gamescope "${inner_cmd[@]}"
}

interactive_new_config() {
  CURRENT_PROFILE=""
  detect_session_mode
  detect_steam_installations
  choose_drm_output
  choose_resolution_profile
  choose_gamescope_rate
  choose_vrr_hdr_and_steamos
  choose_pipewire_debug
  choose_ld_preload_mode
  choose_audio_switch
  choose_pre_post_commands
  save_config
  handle_running_steam_before_launch
  launch_gamescope_session
}

run_from_current_config() {
  detect_session_mode

  if [[ -z "$DRM_SHORT" || -z "$DRM_NATIVE_MODE" ]]; then
    echo "Config incomplete; re-running interactive setup."
    interactive_new_config
  fi

  if [[ -z "${STEAM_TYPE:-}" ]]; then
    STEAM_TYPE="native"
  fi

  PIPEWIRE_DEBUG_MODE=${PIPEWIRE_DEBUG_MODE:-2}
  FORCE_GRAB_CURSOR=${FORCE_GRAB_CURSOR:-0}
  LD_PRELOAD_MODE=${LD_PRELOAD_MODE:-clear}
  G_FPS_BG=${G_FPS_BG:-0}
  AUDIO_SWITCH_ENABLED=${AUDIO_SWITCH_ENABLED:-0}
  AUDIO_SINK_NAME=${AUDIO_SINK_NAME:-""}
  PRE_CMD=${PRE_CMD:-""}
  POST_CMD=${POST_CMD:-""}

  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    if ! command -v flatpak >/dev/null 2>/dev/null || \
       ! flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
      print_warn "Saved config uses Steam Flatpak, but it is not available."
      detect_steam_installations
      save_config
    fi
  elif [[ "$STEAM_TYPE" == "native" ]]; then
    if ! command -v steam >/dev/null 2>&1; then
      print_warn "Saved config uses native Steam, but it is not available."
      detect_steam_installations
      save_config
    fi
  fi

  handle_running_steam_before_launch
  launch_gamescope_session
}

generate_launch_opts() {
  if (( HAVE_CONFIG == 0 || FLAG_NEW )); then
    detect_session_mode
    detect_steam_installations
    choose_drm_output
    choose_resolution_profile
    choose_gamescope_rate
    choose_vrr_hdr_and_steamos
    choose_pipewire_debug
    choose_ld_preload_mode
    choose_audio_switch
    choose_pre_post_commands
    save_config
    HAVE_CONFIG=1
  fi

  print_steam_launch_options
  exit 0
}

kill_gamescope() {
  local had_gs=0
  if pkill gamescope >/dev/null 2>&1; then
    had_gs=1
    print_success "Killed gamescope processes."
  else
    echo "No gamescope processes found."
  fi

  audio_restore_from_state

  if (( had_gs )); then
    run_post_hook
  fi

  return $had_gs
}

interactive_profile_menu() {
  detect_session_mode
  print_config_summary
  echo
  echo "Options:"
  echo "  [1] Use this profile"
  echo "  [2] Select a different profile"
  echo "  [3] Create new profile"
  echo "  [4] Delete a profile"

  local choice=
  while :; do
    read -rp "Choose option [1-4]: " choice || exit 1
    case "$choice" in
      1)
        run_from_current_config
        break
        ;;
      2)
        if select_profile_interactive "use"; then
          load_profile_by_name "$CURRENT_PROFILE"
          run_from_current_config
        else
          echo "No other profiles available. Creating new profile."
          interactive_new_config
        fi
        break
        ;;
      3)
        interactive_new_config
        break
        ;;
      4)
        if select_profile_interactive "delete"; then
          delete_profile "$CURRENT_PROFILE"
        else
          echo "No profiles available to delete."
        fi
        exit 0
        ;;
      *)
        echo "Enter 1, 2, 3, or 4."
        ;;
    esac
  done
}

# ---------------- main ----------------
if [[ ${UID:-$(id -u)} -eq 0 ]]; then
  print_error "Do not run as root. Use your regular user account."
  exit 1
fi

while getopts ":hnlpkdOSc:LD:" opt; do
  case "$opt" in
    h) FLAG_HELP=1 ;;
    n) FLAG_NEW=1 ;;
    l) FLAG_LAST=1 ;;
    p) FLAG_PRINT=1 ;;
    k) FLAG_KILL=1 ;;
    d) FLAG_DETACH=1 ;;
    O) FLAG_LAUNCH_OPTS=1 ;;
    S) FLAG_KILL_STEAM=1 ;;
    c) SELECTED_PROFILE="$OPTARG" ;;
    L) FLAG_LIST_PROFILES=1 ;;
    D) FLAG_DELETE_PROFILE=1; SELECTED_PROFILE="$OPTARG" ;;
    \?) print_error "Unknown option: -$OPTARG"; exit 1 ;;
    :) print_error "Option -$OPTARG requires an argument"; exit 1 ;;
  esac
done
shift $((OPTIND - 1))

if (( FLAG_HELP )); then
  print_help
  exit 0
fi

if (( FLAG_LIST_PROFILES )); then
  list_profiles
  exit 0
fi

if (( FLAG_DELETE_PROFILE )); then
  delete_profile "$SELECTED_PROFILE"
  exit 0
fi

# Load config by explicit -c first, else last_profile
if [[ -n "$SELECTED_PROFILE" && $FLAG_DELETE_PROFILE -eq 0 ]]; then
  load_profile_by_name "$SELECTED_PROFILE"
else
  load_config_default
fi

if (( FLAG_KILL )); then
  kill_gamescope
  exit 0
fi

if (( FLAG_LAUNCH_OPTS )); then
  generate_launch_opts
fi

if (( FLAG_PRINT )); then
  print_config_summary
  exit 0
fi

if [[ -n "$SELECTED_PROFILE" && $FLAG_DELETE_PROFILE -eq 0 ]]; then
  if (( HAVE_CONFIG == 0 )); then
    print_error "Profile '$SELECTED_PROFILE' not found."
    echo "Available profiles:"
    list_profiles
    exit 1
  fi
  run_from_current_config
  exit 0
fi

if (( FLAG_LAST )); then
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config; doing new interactive setup."
    interactive_new_config
    exit 0
  fi
  run_from_current_config
  exit 0
fi

if (( FLAG_NEW )); then
  interactive_new_config
  exit 0
fi

# At this point: no special flags, just plain `smtty`.
# If we don't have a valid last_profile loaded, but profiles exist,
# pick one and THEN go through the normal menu (do not auto-launch).
if (( HAVE_CONFIG == 0 )); then
  if select_profile_interactive "use"; then
    load_profile_by_name "$CURRENT_PROFILE"
  else
    # No profiles at all -> full setup wizard
    interactive_new_config
    exit 0
  fi
fi

# Now we definitely have a loaded profile, so show the menu.
interactive_profile_menu
