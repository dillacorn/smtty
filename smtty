#!/usr/bin/env bash

# SMTTY_VERSION_BLOCK_BEGIN
SMTTY_VERSION="${SMTTY_VERSION:-v11.4}"
SMTTY_REPO="${SMTTY_REPO:-dillacorn/smtty}"
SMTTY_UPDATE_CMD="${SMTTY_UPDATE_CMD:-smtty-update}"

smtty_is_semver_like() {
  # Accept: 10, 10.0, 10.0.1, v10.0.1
  local v="${1#v}"
  [[ "$v" =~ ^[0-9]+([.][0-9]+){0,3}$ ]]
}

smtty_get_latest_tag() {
  local api="https://api.github.com/repos/${SMTTY_REPO}/tags?per_page=1"
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$api" 2>/dev/null | sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]\+\)".*/\1/p' | head -n1
    return 0
  fi
  if command -v wget >/dev/null 2>&1; then
    wget -qO- "$api" 2>/dev/null | sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]\+\)".*/\1/p' | head -n1
    return 0
  fi
  return 1
}

smtty_print_version() {
  local local_tag="$SMTTY_VERSION"
  [[ "$local_tag" == v* ]] || local_tag="v${local_tag}"

  echo "smtty ${local_tag}"

  local latest=""
  latest="$(smtty_get_latest_tag 2>/dev/null || true)"
  if [[ -z "$latest" ]]; then
    echo "Latest tag: (unavailable: no net/curl/wget)"
    echo "Update: ${SMTTY_UPDATE_CMD}"
    return 0
  fi

  echo "Latest tag: ${latest}"

  # Compare if both look like versions
  if smtty_is_semver_like "$local_tag" && smtty_is_semver_like "$latest"; then
    local lv="${local_tag#v}"
    local rv="${latest#v}"
    if [[ "$lv" == "$rv" ]]; then
      echo "Status: up to date"
    else
      # sort -V: highest version last
      local top
      top="$(printf '%s\n%s\n' "$lv" "$rv" | sort -V | tail -n1)"
      if [[ "$top" == "$rv" ]]; then
        echo "Status: update available"
        echo "Run: ${SMTTY_UPDATE_CMD}"
      else
        echo "Status: ahead of latest tag (local dev build?)"
      fi
    fi
  else
    echo "Status: (skipped compare: non-semver tag)"
    echo "Update: ${SMTTY_UPDATE_CMD}"
  fi
}

# Early exit for version query (so we do not have to touch existing getopts)
SMTTY_DOCTOR_REQUESTED=0
for __smtty_arg in "$@"; do
  case "$__smtty_arg" in
    --doctor) SMTTY_DOCTOR_REQUESTED=1 ;;
    -v|--version)
      smtty_print_version
      exit 0
      ;;
  esac
done
unset __smtty_arg
# SMTTY_VERSION_BLOCK_END

# smtty - Steam Machine launcher (gamescope-only)
# Can be run from a bare TTY or from an X11/Wayland session (Hyprland, Sway, KDE, GNOME, etc.).
# Recommended install location:
#   - $HOME/.local/bin/smtty  (user)
#   - /usr/local/bin/smtty    (system-wide)
#
# Modes:
#   Default:
#     Interactive launcher for Steam Gamepad UI (Big Picture) inside gamescope.
#
#   -O
#     Interactively generate ready-to-paste Steam per-game launch options (nested gamescope, no Big Picture) and exit.
#     Lets you choose:
#       - gamescope with or without Steam integration (-e)
#       - background/unfocused FPS limit (-o, from saved config)
#       - flatpak vs native Steam prefix
#
#   -n
#     New interactive setup for smtty config. Prompts for profile name to save.
#
#   -l
#     Use last saved smtty config immediately (no questions).
#     With -l, smtty never kills Steam unless you also pass -S.
#
#   -c <profile>
#     Use specified configuration profile and launch immediately.
#
#   -L
#     List all available configuration profiles and exit.
#
#   -D <profile>
#     Delete specified configuration profile and exit.
#
#   -p
#     Print saved config summary and exit.
#
#   -k
#     Request Steam shutdown to end any running gamescope session and exit.
#     If a profile defines a POST_CMD, it is run after audio restore.
#
#   -d
#     Detach gamescope (run in background, return to shell).
#
#   -S
#     Kill any running Steam client before launching gamescope (no prompt).

set -euo pipefail


# --- CLI payload capture (args after `--`) ---
# In Gamepad UI mode, extra args after `--` are treated as Steam arguments and appended to the Steam command.
# Examples:
#   smtty -c <profile> -- -applaunch 730
#   smtty -c <profile> -- steam -applaunch 730 -tenfoot
SMTTY_CLI_PAYLOAD=()
smtty_capture_cli_payload() {
  SMTTY_CLI_PAYLOAD=()
  local saw_ddash=0
  local a
  for a in "$@"; do
    if (( saw_ddash )); then
      SMTTY_CLI_PAYLOAD+=("$a")
    elif [[ "$a" == "--" ]]; then
      saw_ddash=1
    fi
  done
}
smtty_capture_cli_payload "$@"
# --- end CLI payload capture ---


# >>> SMTTY GPU/DRIVER COMPAT (auto-insert) >>>
# Controls:
#   SMTTY_FORCE_MULTI_XWAYLAND=1   -> force-enable multi-xwayland knobs
#   SMTTY_DISABLE_MULTI_XWAYLAND=1 -> force-disable multi-xwayland knobs
#   SMTTY_DISABLE_NVIDIA_FIXUPS=1  -> do not apply NVIDIA env fixups
#
# Rationale:
# - Intel/unknown stacks are more likely to hit edge cases with multiple Xwaylands.
# - AMD default behavior remains unchanged.
# - NVIDIA fixups are only applied when proprietary driver is detected and vars are unset.

smtty_detect_gpu_vendor() {
  # Returns: amd|nvidia|intel|hybrid|unknown
  # Hybrid is detected when multiple GPU vendors are present (eg. Intel iGPU + NVIDIA dGPU).
  local l
  if command -v lspci >/dev/null 2>&1; then
    l="$(lspci -nn 2>/dev/null | grep -Ei '(VGA|3D|Display)' || true)"
  else
    l=""
  fi

  local has_amd=0 has_nvidia=0 has_intel=0
  if echo "$l" | grep -Eiq '\[1002:'; then has_amd=1; fi
  if echo "$l" | grep -Eiq '\[10de:'; then has_nvidia=1; fi
  if echo "$l" | grep -Eiq '\[8086:'; then has_intel=1; fi

  local count=$((has_amd + has_nvidia + has_intel))
  if (( count >= 2 )); then
    echo "hybrid"
    return 0
  fi
  if (( has_amd )); then
    echo "amd"
    return 0
  fi
  if (( has_nvidia )); then
    echo "nvidia"
    return 0
  fi
  if (( has_intel )); then
    echo "intel"
    return 0
  fi

  # Fallback (older/odd lspci formats)
  if echo "$l" | grep -Eiq 'AMD|ATI'; then echo "amd"; return 0; fi
  if echo "$l" | grep -Eiq 'NVIDIA'; then echo "nvidia"; return 0; fi
  if echo "$l" | grep -Eiq 'Intel'; then echo "intel"; return 0; fi

  echo "unknown"
  return 0
}


smtty_has_nvidia_proprietary() {
  # Best-effort detection; nouveau systems should return false here.
  if [[ -e /proc/driver/nvidia/version ]]; then
    return 0
  fi
  if command -v nvidia-smi >/dev/null 2>&1; then
    return 0
  fi
  return 1
}

# Compute once.
SMTTY_GPU_VENDOR="${SMTTY_GPU_VENDOR:-$(smtty_detect_gpu_vendor)}"

# Default: allow multi-xwayland everywhere except Intel/unknown.
SMTTY_MULTI_XWAYLAND_OK=1
case "$SMTTY_GPU_VENDOR" in
  intel|unknown) SMTTY_MULTI_XWAYLAND_OK=0 ;;
esac

# User overrides.
if [[ "${SMTTY_FORCE_MULTI_XWAYLAND:-0}" == "1" ]]; then
  SMTTY_MULTI_XWAYLAND_OK=1
fi
if [[ "${SMTTY_DISABLE_MULTI_XWAYLAND:-0}" == "1" ]]; then
  SMTTY_MULTI_XWAYLAND_OK=0
fi

# >>> SMTTY GPU/DRIVER COMPAT v2 >>>
# Fix hybrid GPU mis-detection by tying NVIDIA env fixups to the *selected DRM output* GPU.
# Also provides optional per-profile perf env + PipeWire latency helpers.
#
# Active GPU vendor is resolved from /sys/class/drm/card*-<connector>/device/vendor.
# Vendor ids:
#   0x10de NVIDIA, 0x1002 AMD, 0x8086 Intel

smtty_vendor_id_to_name() {
  local vid="${1#0x}"
  vid="${vid,,}"
  case "$vid" in
    10de) echo "nvidia" ;;
    1002) echo "amd" ;;
    8086) echo "intel" ;;
    *)    echo "unknown" ;;
  esac
}

smtty_get_gpu_vendor_for_output() {
  local out="$1"
  local p vid
  # connector entries look like /sys/class/drm/card0-DP-1
  for p in /sys/class/drm/card*-"$out"/device/vendor; do
    if [[ -f "$p" ]]; then
      vid="$(<"$p")"
      smtty_vendor_id_to_name "$vid"
      return 0
    fi
  done
  echo "unknown"
  return 0
}

smtty_refresh_active_gpu_vendor() {
  # Prefer output-specific vendor. Fall back to system-wide vendor detection.
  if [[ -n "${DRM_SHORT:-}" ]]; then
    SMTTY_ACTIVE_GPU_VENDOR="$(smtty_get_gpu_vendor_for_output "$DRM_SHORT")"
  fi
  if [[ -z "${SMTTY_ACTIVE_GPU_VENDOR:-}" || "${SMTTY_ACTIVE_GPU_VENDOR:-}" == "unknown" ]]; then
    SMTTY_ACTIVE_GPU_VENDOR="${SMTTY_GPU_VENDOR:-$(smtty_detect_gpu_vendor)}"
  fi
}

smtty_apply_gpu_env_fixups() {
  # NVIDIA-only env fixups (only if unset), gated to proprietary driver.
  # Crucially: only applied when the selected DRM output lives on NVIDIA.
  smtty_refresh_active_gpu_vendor

  if [[ "${SMTTY_ACTIVE_GPU_VENDOR:-}" == "nvidia" ]] && smtty_has_nvidia_proprietary && [[ "${SMTTY_DISABLE_NVIDIA_FIXUPS:-0}" != "1" ]]; then
    : "${__GLX_VENDOR_LIBRARY_NAME:=nvidia}"
    : "${GBM_BACKEND:=nvidia-drm}"
    export __GLX_VENDOR_LIBRARY_NAME GBM_BACKEND
  fi
}

smtty_apply_pipewire_latency_env() {
  # Optional PipeWire latency hint for gamescope.
  # Use "inherit" (default) unless you know you need this.
  local v="${PIPEWIRE_LATENCY:-inherit}"
  if [[ -n "$v" && "$v" != "inherit" ]]; then
    export PIPEWIRE_LATENCY="$v"
  fi
}

smtty_apply_perf_env_preset() {
  # Optional shader-cache/perf env preset (vendor-aware). Default off.
  # Conservative by design: avoids risky knobs (async, glthread, cleanup disable).
  if [[ "${PERF_ENV_PRESET:-0}" != "1" ]]; then
    return 0
  fi

  smtty_refresh_active_gpu_vendor

  # DXVK: safe for most titles, reduces stutter on first-run/compiles.
  : "${DXVK_STATE_CACHE:=1}"
  export DXVK_STATE_CACHE

  case "${SMTTY_ACTIVE_GPU_VENDOR:-unknown}" in
    amd|intel)
      # Mesa shader cache sizing (kept modest to avoid disk bloat).
      : "${MESA_SHADER_CACHE_MAX_SIZE:=4G}"
      export MESA_SHADER_CACHE_MAX_SIZE
      ;;
    nvidia)
      # NVIDIA GL shader disk cache.
      : "${__GL_SHADER_DISK_CACHE:=1}"
      export __GL_SHADER_DISK_CACHE
      ;;
  esac
}
# <<< SMTTY GPU/DRIVER COMPAT v2 <<<
# <<< SMTTY GPU/DRIVER COMPAT (auto-insert) <<<



# ---------------- colors / logging ----------------
RED=$'\033[0;31m'
YELLOW=$'\033[1;33m'
GREEN=$'\033[0;32m'
BLUE=$'\033[0;34m'
NC=$'\033[0m'

print_error() {
  printf '%s[ERROR]%s %s\n' "$RED" "$NC" "$*" >&2
}

print_warn() {
  printf '%s[WARN]%s %s\n' "$YELLOW" "$NC" "$*"
}

print_info() {
  printf '%s[INFO]%s %s\n' "$BLUE" "$NC" "$*"
}

print_success() {
  printf '%s[OK]%s %s\n' "$GREEN" "$NC" "$*"
}


smtty_doctor() {
  echo "smtty --doctor"
  echo

  local gs
  gs="$(command -v gamescope 2>/dev/null || true)"
  if [[ -n "$gs" ]]; then
    echo "[OK] gamescope: $gs"
  else
    echo "[FAIL] gamescope: not found in PATH"
  fi

  if [[ -n "$gs" ]] && command -v getcap >/dev/null 2>&1; then
    local caps
    caps="$(getcap "$gs" 2>/dev/null || true)"
    if echo "$caps" | grep -q 'cap_sys_nice'; then
      echo "[OK] cap_sys_nice: present"
    else
      echo "[WARN] cap_sys_nice: missing (gamescope scheduling/latency may suffer)"
      echo "      Fix: sudo setcap 'cap_sys_nice=eip' \"$gs\""
      echo "      Note: package updates may remove file capabilities; re-apply if needed."
    fi
  else
    echo "[WARN] getcap not available; cannot check cap_sys_nice"
  fi

  local ml
  ml="$(ulimit -l 2>/dev/null || true)"
  if [[ -n "$ml" ]]; then
    echo "[INFO] memlock (ulimit -l): $ml"
    if [[ "$ml" != "unlimited" && "$ml" =~ ^[0-9]+$ && "$ml" -lt 65536 ]]; then
      echo "[WARN] memlock is low; shader cache/Vulkan may benefit from higher limits."
      echo "      Suggested (system-wide): /etc/security/limits.d/99-gamescope.conf"
      echo "        * soft memlock unlimited"
      echo "        * hard memlock unlimited"
      echo "      Or for your user only:"
      echo "        $USER soft memlock unlimited"
      echo "        $USER hard memlock unlimited"
      echo "      Re-login required."
    fi
  fi

  echo
  echo "[INFO] GPU summary (lspci):"
  if command -v lspci >/dev/null 2>&1; then
    lspci -nn 2>/dev/null | grep -Ei '(VGA|3D|Display)' || true
  else
    echo "  lspci not available"
  fi

  echo
  echo "[INFO] Selected DRM output: ${DRM_SHORT:-"(none)"}"
  smtty_refresh_active_gpu_vendor
  echo "[INFO] Active GPU vendor (by output): ${SMTTY_ACTIVE_GPU_VENDOR:-unknown}"
  echo

  if command -v gamescope-session >/dev/null 2>&1; then
    echo "[INFO] gamescope-session detected."
    echo "      If you want a DM/session workflow, consider using gamescope-session + smtty only for profile generation."
  fi
}

if (( SMTTY_DOCTOR_REQUESTED )); then
  smtty_doctor
  exit 0
fi


# ---------------- Steam command (Gamepad UI) ----------------
# Optional override:
#   STEAM_CMD_OVERRIDE='steam -gamepadui -steamos3 -steamdeck -nochatui'
if [[ "${STEAM_CMD_OVERRIDE-}" != "" ]]; then
  read -ra STEAM_CMD_ARR <<<"$STEAM_CMD_OVERRIDE"
else
  STEAM_CMD_ARR=(steam -gamepadui -steamos3 -steamdeck)
fi

# Steam installation type (set during detection)
STEAM_TYPE=""  # "native" or "flatpak"

# Steam launch mode per profile:
#   gamepad = Steam Gamepad UI inside gamescope
#   pipe    = Desktop Steam outside gamescope; run games in gamescope via smtty -PIPE
STEAM_LAUNCH_MODE="gamepad"

# Session mode: "kms" (bare VT) or "nested" (X11/Wayland compositor)
SESSION_MODE="kms"

# ---------------- config paths ----------------
CONFIG_DIR="$HOME/.config/smtty"
CONFIG_FILE="$CONFIG_DIR/config"          # Legacy single-config location
PROFILES_DIR="$CONFIG_DIR/profiles"       # Directory for named profiles
LAST_PROFILE_FILE="$CONFIG_DIR/last_profile"
AUDIO_STATE_FILE="$CONFIG_DIR/audio_state"
SESSION_STATE_FILE="$CONFIG_DIR/session_state"

CURRENT_PROFILE=""

# Auto NVIDIA Flatpak GBM handling (runtime-only)
AUTO_GBM_BACKENDS_PATH=""

# ---------------- state ----------------
DRM_SHORT=""
DRM_NATIVE_MODE=""
NATIVE_W=0
NATIVE_H=0

GAME_W=0
GAME_H=0
STRETCH_FLAG="none"   # "none" | "stretch"

# Refresh semantics (futureproofed without changing current behavior):
#   G_FPS == 0 means: auto-detect max refresh via modetest if available; otherwise unlimited (omit -r).
#   If user wants a fixed refresh, set G_FPS > 0.
G_FPS=0               # gamescope -r (target display refresh, Hz; 0 = auto/unlimited)
G_FPS_BG=0            # gamescope -o (unfocused refresh, Hz; 0 = disabled / omit -o)

# VRR / HDR / cursor flags
ADAPTIVE_SYNC=0          # 0/1 -> --adaptive-sync
ENABLE_GAMESCOPE_HDR=0   # 0/1 -> --hdr-enabled/ITM
GAMESCOPE_HDR_NITS=1000  # used with --hdr-itm-target-nits
SMTTY_EDID_HDR_PEAK_NITS=""
FORCE_GRAB_CURSOR=0      # 0/1 -> --force-grab-cursor

# Low-latency / tearing (advanced; only meaningful in KMS/embedded sessions)
LOW_LATENCY_TEARING=0   # 0/1: export SteamOS-style tearing capability flags to Steam-in-gamescope

# PipeWire debug control for gamescope
# "inherit" = do not set PIPEWIRE_DEBUG (respect system / environment)
# "0"       = errors only (quiet)
# "1"       = errors + warnings
# "2"       = info
# "3"       = verbose debug
PIPEWIRE_DEBUG_MODE="2"


# PipeWire latency hint for gamescope
# "inherit" = do not set PIPEWIRE_LATENCY (respect system / environment)
# "<frames>/<rate>" = e.g. 128/48000, 64/48000
PIPEWIRE_LATENCY="inherit"

# Optional perf/shader cache env preset (0/1). Default off.
PERF_ENV_PRESET=0

# Active GPU vendor (resolved from selected DRM output; set at runtime)
SMTTY_ACTIVE_GPU_VENDOR=""

# LD_PRELOAD handling for gamescope/Steam
# "inherit" = do not modify LD_PRELOAD
# "clear"   = export LD_PRELOAD="" before launching gamescope
LD_PRELOAD_MODE="inherit"
# Temporary audio switching (PulseAudio / PipeWire via pactl)
AUDIO_SWITCH_ENABLED=0   # 0/1: switch default sink while gamescope runs
AUDIO_SINK_NAME=""       # sink name to use when AUDIO_SWITCH_ENABLED=1

# Optional hooks tied to the profile:
#   PRE_CMD  runs asynchronously before gamescope starts.
#   POST_CMD runs when the gamescope session ends (natural exit, crash, or kill),
#            and also when you explicitly run "smtty -k".
PRE_CMD=""
POST_CMD=""

MISSING_CMDS=()
HAVE_CONFIG=0

# flags
FLAG_HELP=0
FLAG_NEW=0
FLAG_LAST=0
FLAG_PRINT=0
FLAG_KILL=0
FLAG_DETACH=0
FLAG_LAUNCH_OPTS=0    # -O: generate Steam launch options
FLAG_KILL_STEAM=0     # -S: kill Steam client before launching (no prompt)
FLAG_PIPE=0          # -P/-PIPE: run a single game command in gamescope (Steam Launch Options wrapper)
FLAG_LIST_PROFILES=0  # -L: list available profiles
FLAG_DELETE_PROFILE=0 # -D: delete a profile
FLAG_PIPE_STEAM_INTEGRATION=0  # -e: pipe-mode only; enable gamescope Steam integration (-e/--steam)
FLAG_MANGOHUD=0                # -M: wrap the launched command with MangoHud (mangohud --dlsym)
SELECTED_PROFILE=""   # -c <profile>: use specific profile

# back navigation
BACK_SENTINEL="__SMTTY_BACK__"

# ---------------- gamescope desktop-mode kill hack ----------------
# Marker + fallback heuristics without breaking TTY behavior.
#
# Problem:
#   Capturing gamescope output with pipes/process substitution can change
#   whether Steam/gamescope prints the DBus desktop-switch error.
#
# Solution:
#   Prefer logging via `script` (pty) when available so gamescope still
#   believes it's writing to a terminal. Then tail the log for markers.
#   If `script` is missing, fall back to non-parsing heuristics.

line_matches_desktop_switch_marker() {
  local line=$1
  case "$line" in
    *"The name is not activatable"*) return 0 ;;
    *"org.freedesktop.DBus.Error.ServiceUnknown"*) return 0 ;;
  esac
  return 1
}

start_desktop_switch_watcher() {
  # start_desktop_switch_watcher <log_file> <gamescope_pid>
  # Echoes watcher PID, or 0 if not started.
  local log_file=$1
  local gs_pid=${2:-0}

  [[ -n "$log_file" ]] || { echo 0; return 0; }
  command -v tail >/dev/null 2>&1 || { echo 0; return 0; }

  (
    set +e
    tail -n 0 -F "$log_file" 2>/dev/null | while IFS= read -r line; do
      if line_matches_desktop_switch_marker "$line"; then
        print_warn "Detected Desktop Mode marker; requesting Steam shutdown."
        kill_gamescope || true
        break
      fi

      if [[ "$gs_pid" =~ ^[0-9]+$ ]] && (( gs_pid > 0 )); then
        if ! kill -0 "$gs_pid" 2>/dev/null; then
          break
        fi
      fi
    done
  ) &

  echo $!
}

start_steam_child_exit_watcher() {
  # start_steam_child_exit_watcher <gamescope_pid>
  # If Steam payload seems to exit while gamescope is alive, request shutdown.
  # Echoes watcher PID, or 0 if not started.
  local gs_pid=${1:-0}

  [[ "$gs_pid" =~ ^[0-9]+$ ]] || { echo 0; return 0; }
  (( gs_pid > 0 )) || { echo 0; return 0; }
  command -v pgrep >/dev/null 2>&1 || { echo 0; return 0; }

  (
    set +e
    sleep 5

    while kill -0 "$gs_pid" 2>/dev/null; do
      if ! pgrep -P "$gs_pid" -f -i '(steam|steamwebhelper|com\.valvesoftware\.Steam|flatpak)' \
           >/dev/null 2>&1; then
        sleep 2
        if kill -0 "$gs_pid" 2>/dev/null && \
           ! pgrep -P "$gs_pid" -f -i '(steam|steamwebhelper|com\.valvesoftware\.Steam|flatpak)' \
             >/dev/null 2>&1; then
          print_warn "Steam payload appears to have exited; requesting Steam shutdown."
          kill_gamescope || true
          break
        fi
      fi
      sleep 1
    done
  ) &

  echo $!
}

start_desktop_steam_spawn_watcher() {
  # start_desktop_steam_spawn_watcher <gamescope_pid>
  #
  # Futureproofing:
  #   Original implementation could false-positive off any host Steam activity.
  #   This version:
  #     - restricts to current UID
  #     - uses a baseline PID set (only reacts to newly-seen Steam PIDs)
  #     - ignores steamcmd/steamservice/steamwebhelper
  #
  # If a new non-gamepadui Steam appears while gamescope is alive, assume
  # desktop switch attempt and request shutdown.
  #
  # Echoes watcher PID, or 0 if not started.
  local gs_pid=${1:-0}

  [[ "$gs_pid" =~ ^[0-9]+$ ]] || { echo 0; return 0; }
  (( gs_pid > 0 )) || { echo 0; return 0; }
  command -v pgrep >/dev/null 2>&1 || { echo 0; return 0; }

  (
    set +e
    sleep 5

    local uid="${UID:-$(id -u)}"
    local -A baseline=()
    local pid

    while IFS= read -r pid; do
      [[ -n "$pid" ]] || continue
      baseline["$pid"]=1
    done < <(pgrep -u "$uid" -f '(^|/)(steam)([[:space:]]|$)' 2>/dev/null || true)

    while kill -0 "$gs_pid" 2>/dev/null; do
      local found_pid=""
      while IFS= read -r pid; do
        [[ -n "$pid" ]] || continue
        [[ -n "${baseline[$pid]-}" ]] && continue

        # Read cmdline (NUL-separated)
        if [[ -r "/proc/$pid/cmdline" ]]; then
          local cmdline
          cmdline="$(tr '\0' ' ' <"/proc/$pid/cmdline" 2>/dev/null || true)"

          # Ignore obvious non-client tools
          case "$cmdline" in
            *steamwebhelper*) baseline["$pid"]=1; continue ;;
            *steamcmd*)       baseline["$pid"]=1; continue ;;
            *steamservice*)   baseline["$pid"]=1; continue ;;
          esac

          # Ignore anything explicitly gamepadui (inside or outside)
          if [[ "$cmdline" == *"-gamepadui"* ]]; then
            baseline["$pid"]=1
            continue
          fi

          # Ignore if it's a child of gamescope (likely inside session)
          if [[ -r "/proc/$pid/stat" ]]; then
            local ppid
            ppid="$(awk '{print $4}' "/proc/$pid/stat" 2>/dev/null || true)"
            if [[ "$ppid" =~ ^[0-9]+$ ]] && (( ppid == gs_pid )); then
              baseline["$pid"]=1
              continue
            fi
          fi

          # New non-gamepadui steam client found (likely desktop spawn)
          found_pid="$pid"
          break
        fi

        baseline["$pid"]=1
      done < <(pgrep -u "$uid" -f '(^|/)(steam)([[:space:]]|$)' 2>/dev/null || true)

      if [[ -n "$found_pid" ]]; then
        print_warn "Detected host Steam desktop-mode spawn attempt (pid $found_pid); requesting Steam shutdown."
        kill_gamescope || true
        break
      fi

      sleep 1
    done
  ) &

  echo $!
}

# --- Steam installed game picker (auto-launch via -applaunch) -----------------
SMTTY_APPLAUNCH_APPID="${SMTTY_APPLAUNCH_APPID:-}"
SMTTY_APPLAUNCH_NAME="${SMTTY_APPLAUNCH_NAME:-}"

# Persisted auto-launch selection (locked from main menu)
SMTTY_LOCKED_GAME_FILE="$CONFIG_DIR/locked_game"

# --- installed game picker paging ---
SMTTY_GAME_PICKER_PAGE_SIZE_DEFAULT="${SMTTY_GAME_PICKER_PAGE_SIZE_DEFAULT:-20}"
SMTTY_GAME_PICKER_PAGE_SIZE_MAX="${SMTTY_GAME_PICKER_PAGE_SIZE_MAX:-200}"
SMTTY_GAME_PICKER_PAGE_SIZE_FILE="$CONFIG_DIR/game_picker_page_size"

smtty_game_picker_get_page_size() {
  local def="${SMTTY_GAME_PICKER_PAGE_SIZE_DEFAULT:-20}"
  local max="${SMTTY_GAME_PICKER_PAGE_SIZE_MAX:-200}"
  local f="${SMTTY_GAME_PICKER_PAGE_SIZE_FILE:-$CONFIG_DIR/game_picker_page_size}"

  local v=""
  if [[ -r "$f" ]]; then
    v="$(head -n1 "$f" 2>/dev/null | tr -d '\r' || true)"
  fi

  if [[ "$v" =~ ^[0-9]+$ ]] && (( v >= 5 && v <= max )); then
    printf '%s\n' "$v"
  else
    printf '%s\n' "$def"
  fi
}

smtty_game_picker_save_page_size() {
  local n="${1:-}"
  local max="${SMTTY_GAME_PICKER_PAGE_SIZE_MAX:-200}"
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n >= 5 && n <= max )) || return 1
  mkdir -p "$CONFIG_DIR"
  printf '%s\n' "$n" >"$SMTTY_GAME_PICKER_PAGE_SIZE_FILE"
  return 0
}
# --- end installed game picker paging ---


detect_steam_root() {
  # Prefer native Steam root, then Flatpak.
  local cand
  for cand in \
    "${HOME}/.local/share/Steam" \
    "${HOME}/.steam/steam" \
    "${HOME}/.steam/root" \
    "${HOME}/.var/app/com.valvesoftware.Steam/.local/share/Steam"
  do
    if [[ -d "$cand/steamapps" ]]; then
      printf '%s\n' "$cand"
      return 0
    fi
  done
  return 1
}

list_installed_steam_games() {
  # list_installed_steam_games <steam_root>
  # prints TSV: name<TAB>appid (sorted)
  local root="${1:-}"
  [[ -n "$root" ]] || return 1

  python3 - "$root" <<'PY2'
import glob
import os
import re
import sys

root = sys.argv[1]

def unescape_path(s: str) -> str:
    return s.replace(r"\\", "\\")

libs = []
libs.append(root)

vdf = os.path.join(root, "steamapps", "libraryfolders.vdf")
if os.path.isfile(vdf):
    try:
        data = open(vdf, "r", encoding="utf-8", errors="replace").read()
    except Exception:
        data = ""
    for m in re.finditer(r'"path"\s*"([^"]+)"', data):
        p = unescape_path(m.group(1))
        if p:
            libs.append(p)

# Dedup + only libs with steamapps
seen = set()
lib_paths = []
for p in libs:
    p = os.path.normpath(p)
    if p in seen:
        continue
    seen.add(p)
    if os.path.isdir(os.path.join(p, "steamapps")):
        lib_paths.append(p)

games = []
for lib in lib_paths:
    for mf in glob.glob(os.path.join(lib, "steamapps", "appmanifest_*.acf")):
        appid = os.path.basename(mf).split("_", 1)[-1].split(".", 1)[0]
        name = None
        try:
            txt = open(mf, "r", encoding="utf-8", errors="replace").read()
        except Exception:
            continue
        m = re.search(r'^\s*"name"\s*"([^"]*)"\s*$', txt, flags=re.MULTILINE)
        if m:
            name = m.group(1)
        else:
            m = re.search(r'"name"\s*"([^"]*)"', txt)
            if m:
                name = m.group(1)
        if name and appid.isdigit():
            games.append((name, appid))

games.sort(key=lambda t: (t[0].lower(), t[1]))
for name, appid in games:
    sys.stdout.write(f"{name}\t{appid}\n")
PY2
}

smtty_lookup_installed_game_by_appid() {
  local appid="${1:-}"
  [[ -n "$appid" ]] || return 1
  [[ "$appid" =~ ^[0-9]+$ ]] || return 1

  local root
  root="$(detect_steam_root 2>/dev/null)" || return 1

  local name a
  while IFS=$'	' read -r name a; do
    [[ -n "$a" ]] || continue
    if [[ "$a" == "$appid" ]]; then
      printf '%s
' "$name"
      return 0
    fi
  done < <(list_installed_steam_games "$root" 2>/dev/null || true)

  return 1
}

smtty_load_locked_game_if_any() {
  # Only apply in interactive main menu. Never override an explicit selection.
  [[ -n "${SMTTY_APPLAUNCH_APPID:-}" ]] && return 0
  [[ -r "$SMTTY_LOCKED_GAME_FILE" ]] || return 0

  local line
  line="$(head -n1 "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null | tr -d '
' || true)"
  [[ -n "$line" ]] || { rm -f "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null || true; return 0; }

  local name appid
  if [[ "$line" == *$'	'* ]]; then
    name="${line%%$'	'*}"
    appid="${line##*$'	'}"
  else
    # Back-compat: allow appid-only file
    appid="$line"
    name=""
  fi

  if [[ -z "$appid" || ! "$appid" =~ ^[0-9]+$ ]]; then
    rm -f "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null || true
    return 0
  fi

  local installed_name
  installed_name="$(smtty_lookup_installed_game_by_appid "$appid" 2>/dev/null || true)"
  if [[ -z "$installed_name" ]]; then
    # Locked game no longer installed; clear lock and selection.
    rm -f "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null || true
    SMTTY_APPLAUNCH_APPID=""
    SMTTY_APPLAUNCH_NAME=""
    export SMTTY_APPLAUNCH_APPID SMTTY_APPLAUNCH_NAME
    return 0
  fi

  SMTTY_APPLAUNCH_APPID="$appid"
  SMTTY_APPLAUNCH_NAME="$installed_name"
  export SMTTY_APPLAUNCH_APPID SMTTY_APPLAUNCH_NAME

  # Refresh lock file in case display name changed.
  mkdir -p "$CONFIG_DIR"
  printf '%s	%s
' "$SMTTY_APPLAUNCH_NAME" "$SMTTY_APPLAUNCH_APPID" >"$SMTTY_LOCKED_GAME_FILE"
  return 0
}

smtty_lock_selected_game() {
  local appid="${SMTTY_APPLAUNCH_APPID:-}"
  if [[ -z "$appid" ]]; then
    echo "No game selected to lock. Use [G] first."
    return 1
  fi
  [[ "$appid" =~ ^[0-9]+$ ]] || { echo "Invalid selected appid: $appid"; return 1; }

  local installed_name
  installed_name="$(smtty_lookup_installed_game_by_appid "$appid" 2>/dev/null || true)"
  if [[ -z "$installed_name" ]]; then
    echo "Selected game is no longer installed; clearing selection and lock."
    rm -f "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null || true
    SMTTY_APPLAUNCH_APPID=""
    SMTTY_APPLAUNCH_NAME=""
    export SMTTY_APPLAUNCH_APPID SMTTY_APPLAUNCH_NAME
    return 1
  fi

  SMTTY_APPLAUNCH_NAME="$installed_name"
  export SMTTY_APPLAUNCH_NAME

  mkdir -p "$CONFIG_DIR"
  printf '%s	%s
' "$SMTTY_APPLAUNCH_NAME" "$SMTTY_APPLAUNCH_APPID" >"$SMTTY_LOCKED_GAME_FILE"
  echo "Locked: ${SMTTY_APPLAUNCH_NAME} (${SMTTY_APPLAUNCH_APPID})"
  return 0
}

smtty_unlock_selected_game() {
  if [[ -f "$SMTTY_LOCKED_GAME_FILE" ]]; then
    rm -f "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null || true
    echo "Unlocked (will not persist on next run)."
  else
    echo "Already unlocked."
  fi
  return 0
}

pick_installed_steam_game() {
  local __smtty_find=""
  local __smtty_find_inited=0
  local -a __smtty_find_all=()
  local root
  root="$(detect_steam_root)" || { echo "Steam root not found."; return 1; }

  local -a games
  mapfile -t games < <(list_installed_steam_games "$root" || true)
  if (( ${#games[@]} == 0 )); then
    echo "No installed Steam games found (no appmanifest_*.acf)."
    return 1
  fi

  local page_size
  page_size="$(smtty_game_picker_get_page_size 2>/dev/null || true)"
  if [[ ! "$page_size" =~ ^[0-9]+$ ]]; then
    page_size=20
  fi

  local max="${SMTTY_GAME_PICKER_PAGE_SIZE_MAX:-200}"
  local page=0

  while :; do
    # SMTTY_FIND_PATCH_BEGIN
    if (( __smtty_find_inited == 0 )); then
      __smtty_find_all=("${games[@]}")
      __smtty_find_inited=1
    fi
    if [[ -n "$__smtty_find" ]]; then
      local __q="${__smtty_find,,}"
      local -a __tmp=()
      local __g
      for __g in "${__smtty_find_all[@]}"; do
        [[ "${__g,,}" == *"$__q"* ]] && __tmp+=("$__g")
      done
      if (( ${#__tmp[@]} == 0 )); then
        echo "No matches for: $__smtty_find" >&2
        __smtty_find=""
        games=("${__smtty_find_all[@]}")
      else
        games=("${__tmp[@]}")
      fi
    else
      games=("${__smtty_find_all[@]}")
    fi
    # SMTTY_FIND_PATCH_END
    local total=${#games[@]}
    local pages=$(( (total + page_size - 1) / page_size ))
    (( pages < 1 )) && pages=1
    (( page < 0 )) && page=0
    if (( page >= pages )); then
      page=$(( pages - 1 ))
    fi

    local start=$(( page * page_size ))
    local end=$(( start + page_size ))
    (( end > total )) && end=$total
    local on_page=$(( end - start ))

    echo
    echo "Installed Steam games (page $((page + 1))/$pages, showing $((start + 1))-$end of $total, page size $page_size):"
    echo

    local i line name appid local_i
    for (( i = start; i < end; i++ )); do
      line="${games[i]}"
      name="${line%%$'	'*}"
      appid="${line##*$'	'}"
      local_i=$(( i - start + 1 ))
      printf "  [%d] %s (%s)
" "$local_i" "$name" "$appid"
    done

    echo
    echo "  [N] Next page   [P] Previous page   [G] Set page size   [B] Back   [F] Find"
    echo

    printf "Select game (1-%d) or n/p/g/b/f: " "$on_page"
    local ch=""
    IFS= read -rsn1 ch || exit 1

    if [[ "$ch" == $'
' || "$ch" == $'
' ]]; then
      echo
      continue
    fi
case "${ch}" in
    # SMTTY_FIND_CASE_BEGIN
    f|F)
      echo
      read -r -p "Find game name (empty clears): " __smtty_find
    page=0
      continue
      ;;
    # SMTTY_FIND_CASE_END
      [bB])
        echo
        return 1
        ;;
      [nN])
        echo
        if (( page + 1 < pages )); then
          page=$(( page + 1 ))
        fi
        continue
        ;;
      [pP])
        echo
        if (( page > 0 )); then
          page=$(( page - 1 ))
        fi
        continue
        ;;
      [gG])
        echo
        local newps
        if ! backable_read newps "Games per page [$page_size] (5-$max, b = back): "; then
          continue
        fi
        [[ -z "$newps" ]] && newps="$page_size"
        if ! smtty_game_picker_save_page_size "$newps"; then
          echo "Invalid page size. Must be 5-$max."
          continue
        fi
        page_size="$newps"
        page=0
        echo "Saved page size: $page_size"
        continue
        ;;
      [0-9])
        # multi-digit selection: echo first digit, then read rest of line (until Enter)
        printf '%s' "$ch"
        local rest=""
        IFS= read -r rest || true
        local sel="${ch}${rest}"
        sel="${sel//[[:space:]]/}"

        if [[ -z "$sel" || ! "$sel" =~ ^[0-9]+$ ]]; then
          echo "Invalid selection."
          continue
        fi

        if (( sel < 1 || sel > on_page )); then
          echo "Out of range."
          continue
        fi

        local idx=$(( start + sel - 1 ))
        if (( idx < 0 || idx >= total )); then
          echo "Out of range."
          continue
        fi

        line="${games[idx]}"
        SMTTY_APPLAUNCH_NAME="${line%%$'	'*}"
        SMTTY_APPLAUNCH_APPID="${line##*$'	'}"
        export SMTTY_APPLAUNCH_NAME SMTTY_APPLAUNCH_APPID

        echo "Selected: ${SMTTY_APPLAUNCH_NAME} (${SMTTY_APPLAUNCH_APPID})"
        return 0
        ;;
      *)
        echo
        echo "Invalid key."
        continue
        ;;
esac
  done
}

# -----------------------------------------------------------------------------


backable_read() {
  # backable_read <var_name> <prompt>
  local __var_name=$1
  local __prompt=$2
  local __value
  read -rp "$__prompt" __value || exit 1
  if [[ "${__value,,}" == "b" ]]; then
    return 2
  fi
  if [[ "$__value" == "b" ]]; then
    return 1
  fi
  printf -v "$__var_name" '%s' "$__value"
  return 0
}

read_one_key() {
  # read_one_key <var_name> <prompt>
  # Reads a single keypress (no Enter). Returns 1 if key was 'b'.
  local __var_name=$1
  local __prompt=$2
  local __ch=""
  printf '%s' "$__prompt"
  IFS= read -rsn1 __ch || exit 1
  if [[ "${__ch}" == $'\r' || "${__ch}" == $'\n' ]]; then
    __ch=""
  fi
  if [[ "${__ch}" == "B" ]]; then
    __ch="b"
  fi
  printf '\n'
  if [[ "$__ch" == "b" ]]; then
    return 1
  fi
  printf -v "$__var_name" '%s' "$__ch"
  return 0
}

prompt_select() {
  local prompt=$1
  shift
  local count=$#
  local i=1
  local opt
  for opt in "$@"; do
    printf '  [%d] %s\n' "$i" "$opt"
    i=$((i + 1))
  done
  local sel
  while :; do
    if (( count <= 9 )); then
      if ! read_one_key sel "$prompt (1-$count, b = back): "; then
        return 1
      fi
    else
      if ! backable_read sel "$prompt (b = back): "; then
        return 1
      fi
    fi

    if [[ ! "$sel" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( sel >= 1 && sel <= count )); then
      REPLY=$sel
      return 0
    fi
    echo "Out of range."
  done
}

prompt_select_default() {
  local prompt=$1
  local default_index=$2
  shift 2
  local count=$#
  local i=1
  local opt
  for opt in "$@"; do
    printf '  [%d] %s\n' "$i" "$opt"
    i=$((i + 1))
  done
  local sel
  while :; do
    if (( count <= 9 )); then
      if ! read_one_key sel "$prompt [$default_index] (b = back): "; then
        return 1
      fi
    else
      if ! backable_read sel "$prompt [$default_index] (b = back): "; then
        return 1
      fi
    fi

    if [[ -z "$sel" ]]; then
      sel=$default_index
    fi
    if [[ ! "$sel" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( sel >= 1 && sel <= count )); then
      REPLY=$sel
      return 0
    fi
    echo "Out of range."
  done
}

read_default() {
  local prompt=$1
  local def=$2
  local val
  if ! backable_read val "$prompt [$def] (b = back): "; then
    printf '%s\n' "$BACK_SENTINEL"
    return 0
  fi
  if [[ -z "$val" ]]; then
    printf '%s\n' "$def"
  else
    printf '%s\n' "$val"
  fi
}

print_help() {
  cat <<EOF
smtty - Steam Machine launcher (gamescope-only)

Usage:
  smtty [options]

Options:
  -h        Show this help and exit.
  --doctor  Print system capability diagnostics and exit.
  -n        New interactive setup. Prompts for profile name to save.
  -l        Use last saved profile immediately (no questions).
            With -l, smtty never kills Steam unless you also pass -S.
  -c <name> Use specific configuration profile and launch immediately.
  -L        List all available configuration profiles.
  -D <name> Delete specified configuration profile.
  -p        Print saved config summary and exit.
  -k        Request Steam shutdown to end any running gamescope session and exit.
            If the active session profile defines a POST_CMD, it is run after audio restore.
  -d        Detach: start gamescope/Steam in the background and return immediately.
            In detach mode, automatic POST_CMD on gamescope exit is not guaranteed.
            Use 'smtty -k' to ensure POST_CMD runs.
  -S        Kill any running Steam client before launching gamescope (no prompt).
  -v        Print version and check latest tag, then exit. (smtty --version)
  -O        Interactively generate ready-to-paste Steam per-game launch options and exit.
  -P        PIPE mode: run one game command in gamescope using the selected profile.
            Launch Options (native Steam):  smtty -c <profile> -PIPE -- %command%
            Launch Options (Steam Flatpak): flatpak-spawn --host smtty -c <profile> -PIPE -- %command%
  -e        PIPE mode: enable gamescope Steam integration (-e/--steam) for Steam overlay/input.
  -M        Wrap the launched command with MangoHud (mangohud --dlsym). Requires mangohud installed.
  --        (Gamepad UI) Optional Steam args to append to Steam-in-gamescope.
            Example: smtty -c <profile> -- -applaunch 730
                     smtty -c <profile> -- steam -applaunch 730 -tenfoot

Environment:
  STEAM_CMD_OVERRIDE='steam -gamepadui'
      Override the Steam command used (default is auto-chosen native/flatpak).
  PIPEWIRE_DEBUG
      If smtty PipeWire mode is "inherit", this is passed through unchanged.
      Otherwise, smtty overrides it with the selected numeric level.
  LD_PRELOAD
      If smtty LD_PRELOAD mode is "inherit", this is passed through unchanged.
      If mode is "clear", smtty exports LD_PRELOAD="" before gamescope.

Config:
  $PROFILES_DIR/<profile_name>.conf
      Stores named configuration profiles with DRM output, resolution,
      stretch flag, gamescope display rate, unfocused background rate,
      VRR / HDR settings, PipeWire debug level, LD_PRELOAD handling,
      Steam type, optional audio sink switching, and optional pre/post commands.

      PRE_CMD  runs asynchronously before gamescope starts.
      POST_CMD runs when the gamescope session ends (natural exit, crash, or kill),
               and also when you explicitly run 'smtty -k'.

      NOTE: Profile files are sourced as shell (trusted). Do not share profiles you do not trust.

  $LAST_PROFILE_FILE
      Tracks the last used profile name for -l flag.

Examples:
  smtty -n                    # Create new profile (will prompt for name)
  smtty -c gaming             # Launch with 'gaming' profile
  smtty -c 4k-stretched       # Launch with '4k-stretched' profile
  smtty -L                    # List all available profiles
  smtty -D old-config         # Delete 'old-config' profile
  smtty -l                    # Use last profile immediately

Notes:
  - Can be run from a bare TTY (KMS mode) or from inside a compositor
    (Hyprland, Sway, KDE, GNOME, etc.). Resolution and scaling are always
    applied via gamescope runtime flags, not permanent display config writes.
  - Profile names can contain letters, numbers, hyphens, and underscores.
  - Refresh (G_FPS):
      0 = auto-detect max via modetest if available; otherwise unlimited (omit -r).
      >0 = force a fixed refresh via gamescope -r.
EOF
}

# Migrate legacy single config to default profile
migrate_legacy_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    return 0
  fi

  if [[ -d "$PROFILES_DIR" ]] && [[ -f "$PROFILES_DIR/default.conf" ]]; then
    return 0
  fi

  print_info "Migrating legacy config to 'default' profile..."
  mkdir -p "$PROFILES_DIR"
  cp "$CONFIG_FILE" "$PROFILES_DIR/default.conf"
  echo "default" >"$LAST_PROFILE_FILE"
  print_success "Migration complete. Old config preserved at: $CONFIG_FILE"
  echo
}

get_profile_path() {
  local profile_name=$1
  printf '%s/%s.conf' "$PROFILES_DIR" "$profile_name"
}

validate_profile_name() {
  local name=$1
  if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    print_error "Profile name can only contain letters, numbers, hyphens, and underscores."
    return 1
  fi
  if [[ ${#name} -gt 50 ]]; then
    print_error "Profile name too long (max 50 characters)."
    return 1
  fi
  return 0
}

list_profiles() {
  migrate_legacy_config

  if [[ ! -d "$PROFILES_DIR" ]]; then
    echo "No configuration profiles found."
    echo "Create one with: smtty -n"
    return 0
  fi

  local profiles=()
  local last_profile=""

  if [[ -f "$LAST_PROFILE_FILE" ]]; then
    last_profile=$(<"$LAST_PROFILE_FILE")
  fi

  while IFS= read -r -d '' profile_file; do
    local basename="${profile_file##*/}"
    local profile_name="${basename%.conf}"
    profiles+=("$profile_name")
  done < <(find "$PROFILES_DIR" -maxdepth 1 -name "*.conf" -print0 2>/dev/null | sort -z)

  if (( ${#profiles[@]} == 0 )); then
    echo "No configuration profiles found."
    echo "Create one with: smtty -n"
    return 0
  fi

  echo "Available configuration profiles:"
  echo
  local profile
  for profile in "${profiles[@]}"; do
    if [[ "$profile" == "$last_profile" ]]; then
      printf '  • %s %s(last used)%s\n' "$profile" "$GREEN" "$NC"
    else
      printf '  • %s\n' "$profile"
    fi
  done
  echo
  echo "Use with: smtty -c <profile_name>"
  echo "Delete with: smtty -D <profile_name>"
}

delete_profile() {
  local profile_name=$1

  if [[ -z "$profile_name" ]]; then
    print_error "Profile name required. Usage: smtty -D <profile_name>"
    return 1
  fi

  local profile_path
  profile_path=$(get_profile_path "$profile_name")

  if [[ ! -f "$profile_path" ]]; then
    print_error "Profile '$profile_name' does not exist."
    echo "Available profiles:"
    list_profiles
    return 1
  fi

  local ans
  if ! backable_read ans "Delete profile '$profile_name'? [y/N, b = back]: "; then
    echo "Cancelled."
    return 1
  fi
  case "$ans" in
    [yY])
      rm -f "$profile_path"
      print_success "Profile '$profile_name' deleted."

      local last_profile=""
      if [[ -f "$LAST_PROFILE_FILE" ]]; then
        last_profile=$(<"$LAST_PROFILE_FILE")
      fi

      if [[ "$last_profile" == "$profile_name" ]]; then
        local fallback=""

        if [[ -f "$(get_profile_path "default")" ]]; then
          fallback="default"
        else
          local pfile pbase pname
          while IFS= read -r -d '' pfile; do
            pbase="${pfile##*/}"
            pname="${pbase%.conf}"
            if [[ -z "$fallback" ]]; then
              fallback="$pname"
            fi
          done < <(find "$PROFILES_DIR" -maxdepth 1 -name "*.conf" -print0 2>/dev/null | sort -z)
        fi

        if [[ -n "$fallback" ]]; then
          echo "$fallback" >"$LAST_PROFILE_FILE"
          print_info "Last profile changed to '$fallback'."
        else
          rm -f "$LAST_PROFILE_FILE" 2>/dev/null || true
          print_info "No profiles remain. Next launch will run full setup."
        fi
      fi
      ;;
    *)
      echo "Cancelled."
      return 1
      ;;
  esac
  return 0
}

prompt_profile_name() {
  local default_name="default"
  local profile_name

  echo
  echo "Save this configuration as a named profile."
  echo "Examples: gaming, 4k-monitor, stretched-43, desktop-session"
  echo

  while :; do
    if ! backable_read profile_name "Profile name [$default_name] (b = back): "; then
      return 1
    fi

    if [[ -z "$profile_name" ]]; then
      profile_name="$default_name"
    fi

    if ! validate_profile_name "$profile_name"; then
      continue
    fi

    local profile_path
    profile_path=$(get_profile_path "$profile_name")

    if [[ -f "$profile_path" ]]; then
      local ans
      if ! backable_read ans "Profile '$profile_name' already exists. Overwrite? [y/N, b = back]: "; then
        continue
      fi
      case "$ans" in
        [yY]) break ;;
        *) continue ;;
      esac
    else
      break
    fi
  done

  CURRENT_PROFILE="$profile_name"
  echo
  print_info "Will save as profile: $CURRENT_PROFILE"
  echo
  return 0
}

select_profile_interactive() {
  local mode=${1:-use}

  migrate_legacy_config

  if [[ ! -d "$PROFILES_DIR" ]]; then
    return 1
  fi

  local profiles=()

  while IFS= read -r -d '' profile_file; do
    local basename="${profile_file##*/}"
    local profile_name="${basename%.conf}"
    profiles+=("$profile_name")
  done < <(find "$PROFILES_DIR" -maxdepth 1 -name "*.conf" -print0 2>/dev/null | sort -z)

  if (( ${#profiles[@]} == 0 )); then
    return 1
  fi

  if (( ${#profiles[@]} == 1 )); then
    CURRENT_PROFILE="${profiles[0]}"
    echo "Only one profile found: $CURRENT_PROFILE"
    if [[ "$mode" == "use" ]]; then
      echo "Using this profile."
    fi
    echo
    return 0
  fi

  echo "Available profiles:"
  local prompt
  if [[ "$mode" == "delete" ]]; then
    prompt="Select profile to delete"
  else
    prompt="Select profile to use"
  fi
  if ! prompt_select "$prompt" "${profiles[@]}"; then
    return 1
  fi
  CURRENT_PROFILE="${profiles[REPLY-1]}"
  echo
  return 0
}

audio_sink_display_name() {
  local name=$1

  if [[ -z "$name" ]]; then
    printf '%s\n' ""
    return 0
  fi

  if ! command -v pactl >/dev/null 2>&1; then
    printf '%s\n' "$name"
    return 0
  fi

  local desc
  desc=$(pactl list sinks 2>/dev/null | awk -v target="$name" '
    $1 == "Name:" {
      gsub("\r","")
      current = $2
    }
    current == target && $1 == "Description:" {
      $1 = ""
      sub(/^ +/, "")
      gsub("\r","")
      print
      exit
    }
    current == target && $1 == "device.description" && $2 == "=" {
      out = ""
      for (i = 3; i <= NF; ++i) {
        if (i > 3) out = out " "
        out = out $i
      }
      gsub("\r","", out)
      print out
      exit
    }
    current == target && $1 == "node.description" && $2 == "=" {
      out = ""
      for (i = 3; i <= NF; ++i) {
        if (i > 3) out = out " "
        out = out $i
      }
      gsub("\r","", out)
      print out
      exit
    }
  ')

  if [[ -n "$desc" ]]; then
    desc=${desc#\"}
    desc=${desc%\"}
    printf '%s\n' "$desc"
  else
    printf '%s\n' "$name"
  fi
}

print_profile_line() {
  # label | value | note (notes aligned)
  # Tweak widths here.
  local label_w=26
  local value_w=15

  local label="$1"
  local value="$2"
  local note="${3:-}"

  printf "  %-${label_w}s %-${value_w}s %s\n" "$label" "$value" "$note"
}

print_config_summary() {
  # Resolve auto-refresh (G_FPS==0) to detected max if possible.
  init_default_refresh_for_output

  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config loaded"
    return
  fi

  local config_label="Loaded configuration"
  if [[ -n "$CURRENT_PROFILE" ]]; then
    config_label="Profile '$CURRENT_PROFILE'"
  fi

  local pre_display="${PRE_CMD:-}"
  local post_display="${POST_CMD:-}"
  [[ -z "$pre_display" ]] && pre_display="(none)"
  [[ -z "$post_display" ]] && post_display="(none)"

  echo "$config_label:"

  print_profile_line "Steam type:"               "${STEAM_TYPE:-native}"
  print_profile_line "Output:"                   "$DRM_SHORT"
  print_profile_line "Native mode:"              "$DRM_NATIVE_MODE"              "(-W <width> -H <height>)"
  print_profile_line "Game resolution:"          "${GAME_W}x${GAME_H}"            "(-w <width> -h <height>)"
  print_profile_line "Stretch flag:"             "$STRETCH_FLAG"                 "(-S stretch)"
  print_profile_line "gamescope display rate:"   "$G_FPS Hz"                     "(-r <Hz>)"
  print_profile_line "gamescope unfocused rate:" "$G_FPS_BG Hz"                  "(-o <Hz>)"
  print_profile_line "gamescope adaptive-sync:"  "$ADAPTIVE_SYNC"                "(--adaptive-sync)"
  print_profile_line "gamescope HDR enabled:"    "$ENABLE_GAMESCOPE_HDR"         "(--hdr-enabled)"
  print_profile_line "gamescope HDR nits:"       "$GAMESCOPE_HDR_NITS"           "(--hdr-debug-nits <nits>)"
  print_profile_line "gamescope force grab:"     "$FORCE_GRAB_CURSOR"            "(--force-grab-cursor)"
  print_profile_line "Low-latency/tearing:"      "$LOW_LATENCY_TEARING"            "(KMS-only; may tear/break capture)"
  print_profile_line "PipeWire debug mode:"      "$PIPEWIRE_DEBUG_MODE"          "(inherit or 0-3)"
  print_profile_line "LD_PRELOAD mode:"          "${LD_PRELOAD_MODE:-inherit}"     "(inherit or clear)"
  print_profile_line "Audio switch enabled:"     "$AUDIO_SWITCH_ENABLED"

  if (( AUDIO_SWITCH_ENABLED )); then
    local sink_desc
    sink_desc=$(audio_sink_display_name "$AUDIO_SINK_NAME")
    print_profile_line "Audio sink name:"        "${AUDIO_SINK_NAME:-"(unset)"}"
    print_profile_line "Audio sink description:" "${sink_desc:-"(unresolved)"}"
  fi

  print_profile_line "Pre-command (async):"      "$pre_display"
  print_profile_line "Post-command (on exit):"   "$post_display"

  if [[ -n "${AUTO_GBM_BACKENDS_PATH:-}" ]]; then
    print_profile_line "NVIDIA Flatpak GBM path:" "$AUTO_GBM_BACKENDS_PATH"      "(auto)"
  fi
}

save_config() {
  mkdir -p "$PROFILES_DIR"

  if [[ -z "$CURRENT_PROFILE" ]]; then
    if ! prompt_profile_name; then
      return 1
    fi
  fi

  local profile_path
  profile_path=$(get_profile_path "$CURRENT_PROFILE")

  cat >"$profile_path" <<EOF
DRM_SHORT=$DRM_SHORT
DRM_NATIVE_MODE=$DRM_NATIVE_MODE
NATIVE_W=$NATIVE_W
NATIVE_H=$NATIVE_H
GAME_W=$GAME_W
GAME_H=$GAME_H
STRETCH_FLAG=$STRETCH_FLAG
G_FPS=$G_FPS
G_FPS_BG=$G_FPS_BG
STEAM_TYPE=$STEAM_TYPE
STEAM_LAUNCH_MODE=$STEAM_LAUNCH_MODE
ADAPTIVE_SYNC=$ADAPTIVE_SYNC
ENABLE_GAMESCOPE_HDR=$ENABLE_GAMESCOPE_HDR
GAMESCOPE_HDR_NITS=$GAMESCOPE_HDR_NITS
FORCE_GRAB_CURSOR=$FORCE_GRAB_CURSOR
LOW_LATENCY_TEARING=$LOW_LATENCY_TEARING
PIPEWIRE_DEBUG_MODE=$PIPEWIRE_DEBUG_MODE
PIPEWIRE_LATENCY=$PIPEWIRE_LATENCY
PERF_ENV_PRESET=$PERF_ENV_PRESET
LD_PRELOAD_MODE=$LD_PRELOAD_MODE
AUDIO_SWITCH_ENABLED=$AUDIO_SWITCH_ENABLED
AUDIO_SINK_NAME=$AUDIO_SINK_NAME
PRE_CMD=$(printf '%q' "$PRE_CMD")
POST_CMD=$(printf '%q' "$POST_CMD")
EOF

  echo "$CURRENT_PROFILE" >"$LAST_PROFILE_FILE"

  print_success "Configuration saved as profile: $CURRENT_PROFILE"
  return 0
}

load_profile_file() {
  local profile_path=$1

  if [[ ! -r "$profile_path" ]] || [[ ! -s "$profile_path" ]]; then
    print_warn "Profile file exists but is not readable or empty: $profile_path"
    HAVE_CONFIG=0
    return 1
  fi

  # SECURITY NOTE:
  #   This sources shell from the profile file. Treat profiles as trusted input.
  # shellcheck source=/dev/null
  . "$profile_path"
  HAVE_CONFIG=1


  STEAM_LAUNCH_MODE=${STEAM_LAUNCH_MODE:-gamepad}
  PIPEWIRE_DEBUG_MODE=${PIPEWIRE_DEBUG_MODE:-2}
  PIPEWIRE_LATENCY=${PIPEWIRE_LATENCY:-inherit}
  PERF_ENV_PRESET=${PERF_ENV_PRESET:-0}
  FORCE_GRAB_CURSOR=${FORCE_GRAB_CURSOR:-0}
  LOW_LATENCY_TEARING=${LOW_LATENCY_TEARING:-0}
  LD_PRELOAD_MODE=${LD_PRELOAD_MODE:-inherit}
  G_FPS_BG=${G_FPS_BG:-0}
  AUDIO_SWITCH_ENABLED=${AUDIO_SWITCH_ENABLED:-0}
  AUDIO_SINK_NAME=${AUDIO_SINK_NAME:-""}
  PRE_CMD=${PRE_CMD:-""}
  POST_CMD=${POST_CMD:-""}

  return 0
}

load_profile_by_name() {
  local name=$1
  migrate_legacy_config

  if [[ -z "$name" ]]; then
    HAVE_CONFIG=0
    return 1
  fi

  local profile_path
  profile_path=$(get_profile_path "$name")

  if [[ ! -f "$profile_path" ]]; then
    print_error "Profile '$name' not found at: $profile_path"
    echo "Available profiles:"
    list_profiles
    return 1
  fi

  load_profile_file "$profile_path" || return 1

  CURRENT_PROFILE="$name"
  mkdir -p "$CONFIG_DIR"
  echo "$name" >"$LAST_PROFILE_FILE"
  return 0
}

load_config_default() {
  migrate_legacy_config
  HAVE_CONFIG=0

  if [[ ! -f "$LAST_PROFILE_FILE" ]]; then
    return 0
  fi

  local last_profile
  last_profile=$(<"$LAST_PROFILE_FILE")
  if [[ -z "$last_profile" ]]; then
    return 0
  fi

  local profile_path
  profile_path=$(get_profile_path "$last_profile")

  if [[ ! -f "$profile_path" ]]; then
    print_warn "Last profile '$last_profile' no longer exists."
    CURRENT_PROFILE=""
    HAVE_CONFIG=0
    return 0
  fi

  CURRENT_PROFILE="$last_profile"
  load_profile_file "$profile_path" || return 0
}

detect_session_mode() {
  if [[ -n "${WAYLAND_DISPLAY-}" || -n "${DISPLAY-}" ]]; then
    SESSION_MODE="nested"
    LOW_LATENCY_TEARING=0
  else
    SESSION_MODE="kms"
  fi
}


# SMTTY_HYPR_FOCUS_GAMESCOPE_BEGIN
smtty_hypr_focus_gamescope_pid() {
  # In Hyprland nested sessions, window rules can silently shove the gamescope window to another workspace.
  # This attempts to move it back to the currently active workspace and focus it.
  local pid="${1:-}"

  [[ "${SMTTY_HYPR_FOCUS_GAMESCOPE:-1}" == "1" ]] || return 0
  [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]] || return 0

  [[ -n "${HYPRLAND_INSTANCE_SIGNATURE-}" ]] || return 0
  command -v hyprctl >/dev/null 2>&1 || return 0

  local wsid=""
  wsid="$(hyprctl activeworkspace -j 2>/dev/null | sed -n 's/.*"id"[[:space:]]*:[[:space:]]*\([0-9]\+\).*/\1/p' | head -n1 || true)"
  [[ -n "$wsid" && "$wsid" =~ ^[0-9]+$ ]] || return 0

  local i
  for i in {1..30}; do
    hyprctl dispatch movetoworkspacesilent "${wsid},pid:${pid}" >/dev/null 2>&1 || true
    hyprctl dispatch focuswindow "pid:${pid}" >/dev/null 2>&1 || true
    sleep 0.05
  done

  return 0
}
# SMTTY_HYPR_FOCUS_GAMESCOPE_END

# ---------------- NVIDIA + Flatpak GBM autodetect ----------------

have_nvidia_gpu() {
  # Hybrid-safe: only treat as NVIDIA when the selected DRM output is NVIDIA-backed.
  smtty_refresh_active_gpu_vendor
  if [[ "${SMTTY_ACTIVE_GPU_VENDOR:-}" != "nvidia" ]]; then
    return 1
  fi
  if command -v nvidia-smi >/dev/null 2>&1; then
    return 0
  fi
  if [[ -r /proc/driver/nvidia/version ]]; then
    if grep -qi nvidia /proc/driver/nvidia/version; then
      return 0
    fi
  fi
  if command -v lspci >/dev/null 2>&1; then
    if lspci 2>/dev/null | grep -Ei 'vga|3d|display' | grep -qi nvidia; then
      return 0
    fi
  fi
  return 1
}

flatpak_nvidia_gl_dir_name() {
  local appid="com.valvesoftware.Steam"

  if ! command -v flatpak >/dev/null 2>&1; then
    return 1
  fi

  if ! flatpak list --app 2>/dev/null | grep -q "$appid"; then
    return 1
  fi

  flatpak run --command=sh "$appid" -c \
    'ls -1 /usr/lib/x86_64-linux-gnu/GL 2>/dev/null | grep -E "^nvidia-" | head -n 1' \
    2>/dev/null
}

resolve_flatpak_nvidia_gbm_backends_path() {
  local d
  d="$(flatpak_nvidia_gl_dir_name || true)"
  [[ -n "$d" ]] || return 1
  printf '/usr/lib/x86_64-linux-gnu/GL/%s/extra/gbm' "$d"
  return 0
}

maybe_set_flatpak_nvidia_gbm_env() {
  if [[ "${STEAM_TYPE:-}" != "flatpak" ]]; then
    return 0
  fi
  if ! have_nvidia_gpu; then
    return 0
  fi

  if [[ -n "${GBM_BACKENDS_PATH-}" ]]; then
    AUTO_GBM_BACKENDS_PATH="$GBM_BACKENDS_PATH"
    return 0
  fi

  local p
  p="$(resolve_flatpak_nvidia_gbm_backends_path || true)"
  if [[ -n "$p" ]]; then
    export GBM_BACKENDS_PATH="$p"
    AUTO_GBM_BACKENDS_PATH="$p"
  fi
  return 0
}

# ---------------- session state for reliable POST ----------------

write_session_state() {
  local pid=$1
  mkdir -p "$CONFIG_DIR"
  cat >"$SESSION_STATE_FILE" <<EOF
SESSION_PID=$pid
SESSION_PROFILE=$CURRENT_PROFILE
POST_RAN=0
EOF
}

read_session_state() {
  if [[ ! -f "$SESSION_STATE_FILE" ]]; then
    return 1
  fi
  if [[ ! -r "$SESSION_STATE_FILE" ]] || [[ ! -s "$SESSION_STATE_FILE" ]]; then
    rm -f "$SESSION_STATE_FILE" 2>/dev/null || true
    return 1
  fi
  # shellcheck source=/dev/null
  . "$SESSION_STATE_FILE"
  return 0
}

mark_post_ran_for_pid() {
  local pid=$1
  mkdir -p "$CONFIG_DIR"
  cat >"$SESSION_STATE_FILE" <<EOF
SESSION_PID=$pid
SESSION_PROFILE=$CURRENT_PROFILE
POST_RAN=1
EOF
}

post_already_ran_for_pid() {
  local pid=$1
  if ! read_session_state; then
    return 1
  fi
  local spid="${SESSION_PID:-0}"
  local pran="${POST_RAN:-0}"
  if [[ "$spid" =~ ^[0-9]+$ ]] && (( spid == pid )) && [[ "$pran" == "1" ]]; then
    return 0
  fi
  return 1
}

clear_session_state_if_pid_matches() {
  local pid=$1
  if ! read_session_state; then
    return 0
  fi
  local spid="${SESSION_PID:-0}"
  if [[ "$spid" =~ ^[0-9]+$ ]] && (( spid == pid )); then
    rm -f "$SESSION_STATE_FILE" 2>/dev/null || true
  fi
}

# ---------------- output / resolution selection ----------------

# --- HDR EDID nits helpers v4 (smtty) ---
# Reads HDR static metadata from EDID via edid-decode.
# Used only to prefill the HDR ITM target nits prompt default.
# If missing/unavailable, smtty falls back to the saved/default nits value.

smtty_resolve_edid_path() {
  local conn="${1:?missing connector (e.g. DP-1)}"
  local p
  for p in /sys/class/drm/card*-"$conn"/edid; do
    [[ -r "$p" ]] || continue
    printf '%s\n' "$p"
    return 0
  done
  return 1
}

smtty_round_nits() {
  local v="${1:-}"
  awk -v v="$v" 'BEGIN{ if (v ~ /^[0-9]+(\.[0-9]+)?$/) printf "%.0f\n", v }'
}

smtty_get_hdr_peak_nits_for_output() {
  # Prints peak nits from EDID HDR static metadata, or empty.
  local conn="${1:?missing connector (e.g. DP-1)}"
  local edid_path out peak

  command -v edid-decode >/dev/null 2>&1 || return 2
  edid_path="$(smtty_resolve_edid_path "$conn")" || return 1

  out="$(edid-decode "$edid_path" 2>/dev/null || true)"

  # Prefer the cd/m^2 value shown in parentheses by edid-decode:
  # "Desired content max luminance: ... (XXX cd/m^2)"
  peak="$(awk -F'[()]' '/Desired content max luminance:/{
    if (NF>=2) {
      x=$2
      gsub(/[^0-9.]/,"",x)
      if (x!="") { print x; exit }
    }
  }' <<<"$out")"

  # Fallback: if no parentheses, take the last numeric token on the line.
  if [[ -z "$peak" ]]; then
    peak="$(awk '/Desired content max luminance:/{
      for (i=NF; i>=1; i--) {
        if ($i ~ /^[0-9]+(\.[0-9]+)?$/) { print $i; exit }
      }
    }' <<<"$out")"
  fi

  peak="$(smtty_round_nits "$peak" || true)"
  [[ -n "$peak" ]] || return 3

  # Reject 0/negative junk.
  if ! [[ "$peak" =~ ^[0-9]+$ ]]; then
    return 3
  fi
  if (( peak <= 0 )); then
    return 3
  fi

  printf '%s\n' "$peak"
}
# --- end HDR EDID nits helpers v4 ---


detect_max_refresh_for_current_output() {
  # Best-effort detection of the highest refresh rate at the native
  # resolution for the currently selected DRM connector ($DRM_SHORT).
  # Requires: DRM_SHORT, NATIVE_W, NATIVE_H; uses `modetest -c` if present.
  if [[ -z "${DRM_SHORT:-}" ]]; then
    return 1
  fi
  if (( NATIVE_W <= 0 || NATIVE_H <= 0 )); then
    return 1
  fi
  if ! command -v modetest >/dev/null 2>&1; then
    return 1
  fi

  local native
  native="${NATIVE_W}x${NATIVE_H}"

  modetest -c 2>/dev/null | awk -v out="$DRM_SHORT" -v native="$native" '
    BEGIN {
      connectors = 0;
      found = 0;
      in_modes = 0;
      max = 0;
    }

    $1 == "Connectors:" {
      connectors = 1;
      next;
    }

    !connectors {
      next;
    }

    # Connector line: id encoder status name size(mm) modes encoders
    $1 ~ /^[0-9]+$/ && $4 == out {
      found = 1;
      in_modes = 0;
      next;
    }

    found && $1 == "modes:" {
      in_modes = 1;
      next;
    }

    # End of this connectors mode list
    found && in_modes && ($1 == "props:" || $1 == "encoders:" || $1 == "CRTCs:" || $1 == "id") {
      in_modes = 0;
      found = 0;
      next;
    }

    found && in_modes {
      mode = "";
      hz = 0;

      # Formats:
      #   "#0 1920x1080 60.00 ..."   (indexed)
      #   "1920x1080 60.00 ..."      (no index)
      if ($1 ~ /^#?[0-9]+$/ && $2 ~ /^[0-9]+x[0-9]+$/) {
        mode = $2;
        hz = $3;
      } else if ($1 ~ /^[0-9]+x[0-9]+$/) {
        mode = $1;
        hz = $2;
      } else {
        next;
      }

      # Only consider native resolution for this output
      if (native != "" && mode != native) {
        next;
      }

      # Strip trailing .00 etc
      gsub(/\.[0-9]+$/, "", hz);

      if (hz + 0 > max) {
        max = hz + 0;
      }
    }

    END {
      if (max > 0) {
        printf "%d\n", max;
      }
    }
  '
}

init_default_refresh_for_output() {
  # Current behavior preserved:
  #   If G_FPS == 0: try to auto-detect max refresh via modetest.
  #   If modetest not available or parse fails: leave at 0 (unlimited / omit -r).
  if (( G_FPS != 0 )); then
    return 0
  fi
  if [[ -z "${DRM_SHORT:-}" ]]; then
    return 0
  fi
  if (( NATIVE_W <= 0 || NATIVE_H <= 0 )); then
    return 0
  fi
  if ! command -v modetest >/dev/null 2>&1; then
    return 0
  fi

  local detected=""
  detected=$(detect_max_refresh_for_current_output 2>/dev/null || true)

  if [[ "$detected" =~ ^[0-9]+$ ]] && (( detected > 0 )); then
    G_FPS=$detected
    print_info "Auto-detected max refresh for $DRM_SHORT at ${NATIVE_W}x${NATIVE_H}: ${G_FPS} Hz"
    echo
  fi
}

choose_drm_output() {
  echo "Detected *connected* outputs:"
  echo

  local entries=()
  local idx=1
  local status_path status dir modes_path short native_line

  for status_path in /sys/class/drm/card*-*/status; do
    [[ -f "$status_path" ]] || continue
    status=$(<"$status_path")
    [[ "$status" == "connected" ]] || continue

    dir=${status_path%/status}
    modes_path="$dir/modes"
    [[ -f "$modes_path" ]] || continue

    short=${dir##*/}
    short=${short#card*-}

    native_line="unknown"
    local max_area=0
    local mline mw mh area
    while IFS= read -r mline; do
      [[ -z "$mline" ]] && continue
      if [[ "$mline" =~ ([0-9]+)x([0-9]+) ]]; then
        mw=${BASH_REMATCH[1]}
        mh=${BASH_REMATCH[2]}
        area=$(( mw * mh ))
        if (( area > max_area )); then
          max_area=$area
          native_line="$mline"
        fi
      fi
    done <"$modes_path"

    entries+=("$short:$native_line")
    printf '  [%d] %s (native: %s)\n' "$idx" "$short" "$native_line"
    idx=$((idx + 1))
  done

  if ((${#entries[@]} == 0)); then
    print_error "No *connected* DRM outputs found under /sys/class/drm."
    exit 1
  fi

  local choice
  while :; do
    if ((${#entries[@]} <= 9)); then
      if ! read_one_key choice "Select output [1-${#entries[@]}, b = back]: "; then
        return 1
      fi
    else
      if ! backable_read choice "Select output [1-${#entries[@]}, b = back]: "; then
        return 1
      fi
    fi

    if [[ ! "$choice" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( choice >= 1 && choice <= ${#entries[@]} )); then
      break
    fi
    echo "Out of range."
  done

  local chosen=${entries[choice-1]}
  DRM_SHORT=${chosen%%:*}

  # Tie GPU fixups to the selected connector's GPU (hybrid-safe)
  SMTTY_ACTIVE_GPU_VENDOR="$(smtty_get_gpu_vendor_for_output "$DRM_SHORT")"
  DRM_NATIVE_MODE=${chosen#*:}

  # Detect EDID-reported HDR peak nits for this output (optional; used as HDR prompt default).
  SMTTY_EDID_HDR_PEAK_NITS=""
  SMTTY_EDID_HDR_PEAK_NITS="$(smtty_get_hdr_peak_nits_for_output "$DRM_SHORT" 2>/dev/null || true)"

  local base=${DRM_NATIVE_MODE%%@*}
  if [[ "$base" =~ ^([0-9]+)x([0-9]+)$ ]]; then
    NATIVE_W=${BASH_REMATCH[1]}
    NATIVE_H=${BASH_REMATCH[2]}
  else
    print_error "Failed to parse native mode \"$DRM_NATIVE_MODE\"; expected WxH[@Hz]."
    exit 1
  fi

  echo
  echo "Using output: $DRM_SHORT (native ${NATIVE_W}x${NATIVE_H})"
  echo "Session mode: $SESSION_MODE (kms = bare VT, nested = under compositor)"
  echo
  if [[ "$SESSION_MODE" == "nested" ]]; then
    echo "Note: running under a compositor. gamescope will be nested as a window"
    echo "      or fullscreen surface. Physical monitor resolution is not changed,"
    echo "      but gamescope still controls internal and outer resolutions/scaling."
    echo
  fi

  # Auto-initialize default refresh to the highest supported rate
  # for this connector at its native resolution, if G_FPS is still 0.
  init_default_refresh_for_output

  return 0
}

choose_resolution_profile() {
  GAME_W=$NATIVE_W
  GAME_H=$NATIVE_H
  STRETCH_FLAG="none"

  custom_resolution_prompt() {
    local w h
    while :; do
      read -r -p "Custom width in px [${NATIVE_W}] (or 'q' to cancel): " w
      [[ $w == "q" || $w == "Q" ]] && return 1
      w="${w:-$NATIVE_W}"
      [[ $w =~ ^[0-9]+$ ]] && (( w >= 320 && w <= 16384 )) && break
      echo "Invalid width: $w"
    done
    while :; do
      read -r -p "Custom height in px [${NATIVE_H}] (or 'q' to cancel): " h
      [[ $h == "q" || $h == "Q" ]] && return 1
      h="${h:-$NATIVE_H}"
      [[ $h =~ ^[0-9]+$ ]] && (( h >= 240 && h <= 16384 )) && break
      echo "Invalid height: $h"
    done
    GAME_W=$w
    GAME_H=$h
    return 0
  }

  ask_stretch_if_needed() {
    STRETCH_FLAG="none"

    # Same resolution or same aspect ratio: no stretch question.
    if (( GAME_W == NATIVE_W && GAME_H == NATIVE_H )); then
      return 0
    fi
    if (( GAME_W * NATIVE_H == GAME_H * NATIVE_W )); then
      return 0
    fi

    local _saved_reply="${REPLY-}"
    if ! prompt_select_default "Stretch mode" 1 \
      "Stretch to fill ${NATIVE_W}x${NATIVE_H} (distorts)" \
      "Keep aspect (black bars)"; then
      return 1
    fi
    local stretch_choice="$REPLY"
    REPLY="$_saved_reply"

    case "$stretch_choice" in
      1) STRETCH_FLAG="stretch" ;;
      2) STRETCH_FLAG="none" ;;
    esac
    return 0
  }

  if [[ $NATIVE_W -eq 1920 && $NATIVE_H -eq 1080 ]]; then
    echo "Resolution profile for 1080p 16:9:"
    if ! prompt_select_default "Choose profile" 1 \
      "Native 1920x1080" \
      "1280x960 (4:3 base)" \
      "1440x1080 (4:3 base)" \
      "1352x1080 (4:3 base)" \
      "1600x1200 (4:3 base, downscale)" \
      "1680x1050 (16:10 base)" \
      "1728x1080 (16:10 base)" \
      "1920x1200 (16:10 base, downscale)" \
      "Custom"; then
      return 1
    fi
    case "$REPLY" in
      1) GAME_W=1920; GAME_H=1080 ;;
      2) GAME_W=1280; GAME_H=960 ;;
      3) GAME_W=1440; GAME_H=1080 ;;
      4) GAME_W=1352; GAME_H=1080 ;;
      5) GAME_W=1600; GAME_H=1200 ;;
      6) GAME_W=1680; GAME_H=1050 ;;
      7) GAME_W=1728; GAME_H=1080 ;;
      8) GAME_W=1920; GAME_H=1200 ;;
      9) custom_resolution_prompt || return 1 ;;
    esac
    ask_stretch_if_needed || return 1

  elif [[ $NATIVE_W -eq 2560 && $NATIVE_H -eq 1440 ]]; then
    echo "Resolution profile for 1440p 16:9:"
    if ! prompt_select_default "Choose profile" 1 \
      "Native 2560x1440" \
      "1600x1200 (4:3 base)" \
      "1920x1440 (4:3 base)" \
      "1920x1200 (16:10 base)" \
      "2304x1440 (16:10 base)" \
      "Custom"; then
      return 1
    fi
    case "$REPLY" in
      1) GAME_W=2560; GAME_H=1440 ;;
      2) GAME_W=1600; GAME_H=1200 ;;
      3) GAME_W=1920; GAME_H=1440 ;;
      4) GAME_W=1920; GAME_H=1200 ;;
      5) GAME_W=2304; GAME_H=1440 ;;
      6) custom_resolution_prompt || return 1 ;;
    esac
    ask_stretch_if_needed || return 1

  elif [[ $NATIVE_W -eq 3840 && $NATIVE_H -eq 2160 ]]; then
    echo "Resolution profile for 4K 16:9:"
    if ! prompt_select_default "Choose profile" 1 \
      "Native 3840x2160" \
      "2560x1440 (downscale base)" \
      "1920x1440 (4:3 base)" \
      "2880x2160 (4:3 base)" \
      "3200x2400 (4:3 base)" \
      "1920x1200 (16:10 base)" \
      "2560x1600 (16:10 base)" \
      "2880x1800 (16:10 base)" \
      "3200x2000 (16:10 base)" \
      "3456x2160 (16:10 base)" \
      "Custom"; then
      return 1
    fi
    case "$REPLY" in
      1)  GAME_W=3840; GAME_H=2160 ;;
      2)  GAME_W=2560; GAME_H=1440 ;;
      3)  GAME_W=1920; GAME_H=1440 ;;
      4)  GAME_W=2880; GAME_H=2160 ;;
      5)  GAME_W=3200; GAME_H=2400 ;;
      6)  GAME_W=1920; GAME_H=1200 ;;
      7)  GAME_W=2560; GAME_H=1600 ;;
      8)  GAME_W=2880; GAME_H=1800 ;;
      9)  GAME_W=3200; GAME_H=2000 ;;
      10) GAME_W=3456; GAME_H=2160 ;;
      11) custom_resolution_prompt || return 1 ;;
    esac
    ask_stretch_if_needed || return 1
  fi
}

choose_gamescope_rate() {
  local val
  val=$(read_default "Target display refresh for gamescope (-r, Hz; 0 = auto-detect max via modetest, else unlimited)" "$G_FPS")
  if [[ "$val" == "$BACK_SENTINEL" ]]; then
    return 1
  fi
  if [[ ! "$val" =~ ^[0-9]+$ ]]; then
    echo "Invalid value; using 0."
    val=0
  fi
  G_FPS=$val

  echo
  local raw
  if ! backable_read raw "Nested unfocused refresh (-o, Hz, empty = disabled, b = back): "; then
    return 1
  fi
  if [[ -z "$raw" ]]; then
    G_FPS_BG=0
  elif [[ "$raw" =~ ^[0-9]+$ ]]; then
    G_FPS_BG=$raw
  else
    echo "Invalid value; disabling -o."
    G_FPS_BG=0
  fi
  echo
  return 0
}

choose_vrr_hdr_and_steamos() {
  echo "Optional gamescope features:"

  local vrr
  while :; do
    vrr=$(read_default "Enable gamescope adaptive sync / VRR? (0 = no, 1 = yes)" "$ADAPTIVE_SYNC")
    if [[ "$vrr" == "$BACK_SENTINEL" ]]; then
      return 1
    fi
    case "$vrr" in
      0|1)
        ADAPTIVE_SYNC=$vrr
        break
        ;;
      *)
        echo "Enter 0 or 1."
        ;;
    esac
  done

  local hdr
  while :; do
    hdr=$(read_default "Enable gamescope HDR output? (0 = no, 1 = yes)" "$ENABLE_GAMESCOPE_HDR")
    if [[ "$hdr" == "$BACK_SENTINEL" ]]; then
      return 1
    fi
    case "$hdr" in
      0|1)
        break
        ;;
      *)
        echo "Enter 0 or 1."
        ;;
    esac
  done

  if [[ "$hdr" == "1" ]]; then
    ENABLE_GAMESCOPE_HDR=1
    local nits
    local default_nits="$GAMESCOPE_HDR_NITS"

    # Prefer EDID peak nits as the prompt default ONLY when current/saved is the generic 1000.
    if command -v edid-decode >/dev/null 2>&1; then
      if [[ -n "${SMTTY_EDID_HDR_PEAK_NITS:-}" ]]; then
        if [[ -z "${GAMESCOPE_HDR_NITS:-}" || "${GAMESCOPE_HDR_NITS:-}" == "1000" ]]; then
          default_nits="$SMTTY_EDID_HDR_PEAK_NITS"
        fi
      fi
    else
      print_warn "edid-decode not found; cannot auto-detect HDR nits from EDID. Install it for per-display defaults."
    fi

    nits=$(read_default "HDR ITM target nits (gamescope --hdr-itm-target-nits)" "$default_nits")
    if [[ "$nits" == "$BACK_SENTINEL" ]]; then
      return 1
    fi
    if [[ "$nits" =~ ^[0-9]+$ ]]; then
      GAMESCOPE_HDR_NITS=$nits
    else
      echo "Invalid nits value; keeping $GAMESCOPE_HDR_NITS."
    fi
  else
    ENABLE_GAMESCOPE_HDR=0
  fi

  echo
  echo "Cursor grab:"
  echo "  Mostly useful on bare TTY (KMS). In nested sessions it can make"
  echo "  mouse input worse if games and overlays already manage grabs."

  local fg
  while :; do
    fg=$(read_default "Force gamescope cursor grab? (0 = no, 1 = yes)" "$FORCE_GRAB_CURSOR")
    if [[ "$fg" == "$BACK_SENTINEL" ]]; then
      return 1
    fi
    case "$fg" in
      0|1)
        FORCE_GRAB_CURSOR=$fg
        break
        ;;
      *)
        echo "Enter 0 or 1."
        ;;
    esac
  done
  echo
  if [[ "$SESSION_MODE" == "kms" ]]; then
    echo "Low-latency / tearing (advanced, KMS sessions only):"
    echo "  Enables SteamOS-style tearing capability flags for Steam running inside gamescope."
    echo "  Can reduce latency, but may cause visible tearing, break capture, or regress smoothness."
    local lt
    while :; do
      lt=$(read_default "Enable low-latency / tearing mode? (0 = no, 1 = yes)" "$LOW_LATENCY_TEARING")
      if [[ "$lt" == "$BACK_SENTINEL" ]]; then
        return 1
      fi
      case "$lt" in
        0|1)
          LOW_LATENCY_TEARING=$lt
          break
          ;;
        *)
          echo "Enter 0 or 1."
          ;;
      esac
    done
  else
    LOW_LATENCY_TEARING=0
  fi


  echo
  return 0
}

choose_pipewire_debug() {
  echo "PipeWire / gamescope log verbosity:"
  echo "  This controls PIPEWIRE_DEBUG for the gamescope process only."
  echo "  Lower values reduce spam like 'pipewire: warning: out of buffers'."
  echo
  echo "  [1] Inherit system default (do not set PIPEWIRE_DEBUG)"
  echo "  [2] Quiet: errors only [PIPEWIRE_DEBUG=0]"
  echo "  [3] Errors + warnings [PIPEWIRE_DEBUG=1]"
  echo "  [4] Info (more detail) [PIPEWIRE_DEBUG=2]"
  echo "  [5] Verbose debug [PIPEWIRE_DEBUG=3]"

  local default_choice
  case "$PIPEWIRE_DEBUG_MODE" in
    inherit) default_choice=1 ;;
    0)       default_choice=2 ;;
    1)       default_choice=3 ;;
    2)       default_choice=4 ;;
    3)       default_choice=5 ;;
    *)       default_choice=4 ;;
  esac

  local sel
  sel=$(read_default "Choose PipeWire debug level (1-5)" "$default_choice")
  if [[ "$sel" == "$BACK_SENTINEL" ]]; then
    return 1
  fi

  if [[ ! "$sel" =~ ^[1-5]$ ]]; then
    echo "Invalid selection; keeping current PipeWire debug mode: $PIPEWIRE_DEBUG_MODE"
  else
    case "$sel" in
      1) PIPEWIRE_DEBUG_MODE="inherit" ;;
      2) PIPEWIRE_DEBUG_MODE="0" ;;
      3) PIPEWIRE_DEBUG_MODE="1" ;;
      4) PIPEWIRE_DEBUG_MODE="2" ;;
      5) PIPEWIRE_DEBUG_MODE="3" ;;
    esac
  fi

  echo
  echo "PipeWire debug mode set to: $PIPEWIRE_DEBUG_MODE"
  echo "  inherit  = smtty leaves PIPEWIRE_DEBUG alone"
  echo "  0        = only errors (very quiet)"
  echo "  1        = errors + warnings"
  echo "  2        = info"
  echo "  3        = verbose debug"
  echo
  return 0
}

choose_pipewire_latency() {
  echo
  echo "PipeWire latency hint (optional)."
  echo "  This sets PIPEWIRE_LATENCY for gamescope only."
  echo "  Use 'inherit' unless you know you need this."
  echo "  Examples: 128/48000  64/48000"
  echo

  local cur="${PIPEWIRE_LATENCY:-inherit}"
  local val
  while :; do
    val="$(read_default "PIPEWIRE_LATENCY" "$cur")"
    if [[ "$val" == "$BACK_SENTINEL" ]]; then
      return 1
    fi

    [[ -z "$val" ]] && val="inherit"

    if [[ "$val" == "inherit" ]]; then
      PIPEWIRE_LATENCY="inherit"
      echo "PipeWire latency env set to: inherit"
      return 0
    fi

    if [[ "$val" =~ ^[0-9]+/[0-9]+$ ]]; then
      PIPEWIRE_LATENCY="$val"
      echo "PipeWire latency env set to: $PIPEWIRE_LATENCY"
      return 0
    fi

    echo "Invalid value. Use 'inherit' or '<frames>/<rate>' (e.g. 128/48000)."
  done
}

choose_perf_env_preset() {
  echo
  echo "Perf/shader cache preset (optional)."
  echo "  Goal: reduce shader-compilation stutter on some titles across launches."
  echo "  0 = off (default)"
  echo "  1 = on  (enables extra caching; uses more disk space)"
  echo "  Notes:"
  echo "    - Applies only to this smtty session/profile (not global)."
  echo "    - Not an FPS boost. May do nothing depending on game/renderer."
  echo "    - What it sets (vendor-aware):"
  echo "      * DXVK_STATE_CACHE=1"
  echo "      * AMD/Intel (Mesa): MESA_SHADER_CACHE_MAX_SIZE=4G"
  echo "      * NVIDIA (OpenGL): __GL_SHADER_DISK_CACHE=1"
  echo

  local cur="${PERF_ENV_PRESET:-0}"
  local val
  while :; do
    val="$(read_default "PERF_ENV_PRESET (0/1)" "$cur")"
    if [[ "$val" == "$BACK_SENTINEL" ]]; then
      return 1
    fi

    if [[ "$val" == "0" || "$val" == "1" ]]; then
      PERF_ENV_PRESET="$val"
      echo "Perf env preset set to: $PERF_ENV_PRESET"
      return 0
    fi

    echo "Invalid value. Enter 0 or 1."
  done
}

choose_ld_preload_mode() {
  echo "LD_PRELOAD handling for gamescope / Steam:"
  echo "  Clearing LD_PRELOAD avoids inherited overlays/shims (MangoHud, vkBasalt,"
  echo "  etc.) from injecting into gamescope or the game."
  echo
  echo "  [1] Inherit current LD_PRELOAD (do nothing)"
  echo "  [2] Clear LD_PRELOAD for gamescope and Steam"

  local default_choice
  case "$LD_PRELOAD_MODE" in
    inherit) default_choice=1 ;;
    clear)   default_choice=2 ;;
    *)       default_choice=1 ;;
  esac

  local sel
  sel=$(read_default "Choose LD_PRELOAD mode (1-2)" "$default_choice")
  if [[ "$sel" == "$BACK_SENTINEL" ]]; then
    return 1
  fi

  case "$sel" in
    1) LD_PRELOAD_MODE="inherit" ;;
    2) LD_PRELOAD_MODE="clear" ;;
    *)
      echo "Invalid selection; keeping current LD_PRELOAD mode: $LD_PRELOAD_MODE"
      ;;
  esac

  echo
  echo "LD_PRELOAD mode set to: $LD_PRELOAD_MODE"
  echo "  inherit = pass through existing LD_PRELOAD"
  echo "  clear   = export LD_PRELOAD=\"\" before gamescope"
  echo
  return 0
}

choose_audio_switch() {
  echo "Temporary audio output switching (PulseAudio / PipeWire via pactl):"

  if ! command -v pactl >/dev/null 2>&1; then
    echo "  pactl not found; audio device switching will be disabled."
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return 0
  fi

  local en
  en=$(read_default "Enable automatic audio output switch while gamescope is running? (0 = no, 1 = yes)" 0)
  if [[ "$en" == "$BACK_SENTINEL" ]]; then
    return 1
  fi

  if [[ "$en" == "1" ]]; then
    AUDIO_SWITCH_ENABLED=1
  else
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return 0
  fi

  mapfile -t sink_lines < <(pactl list short sinks 2>/dev/null || true)

  if ((${#sink_lines[@]} == 0)); then
    echo "  No sinks found; disabling audio switching."
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return 0
  fi

  local -a sink_names=()
  local -a sink_descs=()
  local line name idx

  for line in "${sink_lines[@]}"; do
    read -r idx name _ <<<"$line"
    if [[ -z "$name" ]]; then
      continue
    fi
    sink_names+=("$name")
    sink_descs+=("$(audio_sink_display_name "$name")")
  done

  if ((${#sink_names[@]} == 0)); then
    echo "  No valid sinks parsed; disabling audio switching."
    AUDIO_SWITCH_ENABLED=0
    AUDIO_SINK_NAME=""
    echo
    return 0
  fi

  echo
  echo "Available audio outputs (PulseAudio / PipeWire sinks):"
  local i
  for ((i = 0; i < ${#sink_names[@]}; i++)); do
    local desc="${sink_descs[i]}"
    local raw="${sink_names[i]}"
    if [[ -n "$desc" && "$desc" != "$raw" ]]; then
      printf '  [%d] %s (%s)\n' "$((i + 1))" "$desc" "$raw"
    else
      printf '  [%d] %s\n' "$((i + 1))" "$raw"
    fi
  done

  local choice
  while :; do
    if ((${#sink_names[@]} <= 9)); then
      if ! read_one_key choice "Choose sink to use while gamescope is running [1-${#sink_names[@]}, b = back]: "; then
        return 1
      fi
    else
      if ! backable_read choice "Choose sink to use while gamescope is running [1-${#sink_names[@]}, b = back]: "; then
        return 1
      fi
    fi
    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#sink_names[@]} )); then
      break
    fi
    echo "Enter a number between 1 and ${#sink_names[@]}."
  done

  AUDIO_SINK_NAME=${sink_names[choice-1]}

  echo
  echo "Audio switcher will use:"
  echo "  Description: ${sink_descs[choice-1]}"
  echo "  Name:        ${AUDIO_SINK_NAME}"
  echo
  return 0
}

choose_pre_post_commands() {
  echo "Optional pre / post shell commands for this profile:"
  echo "  Pre-command runs asynchronously before gamescope starts."
  echo "  Post-command runs when the gamescope session ends."
  echo "  Leave empty to skip."
  echo

  local pre
  pre=$(read_default "Pre-command (empty = none)" "${PRE_CMD:-}")
  if [[ "$pre" == "$BACK_SENTINEL" ]]; then
    return 1
  fi
  PRE_CMD="$pre"

  local post
  post=$(read_default "Post-command (empty = none)" "${POST_CMD:-}")
  if [[ "$post" == "$BACK_SENTINEL" ]]; then
    return 1
  fi
  POST_CMD="$post"

  echo
  return 0
}

get_default_sink() {
  local current=""
  current=$(pactl get-default-sink 2>/dev/null || true)
  if [[ -z "$current" ]]; then
    current=$(pactl info 2>/dev/null | awk -F': ' '/Default Sink:/ {print $2; exit}')
  fi
  printf '%s\n' "$current"
}

audio_switch_can_run() {
  if (( AUDIO_SWITCH_ENABLED != 1 )); then
    return 1
  fi
  if [[ -z "$AUDIO_SINK_NAME" ]]; then
    return 1
  fi
  if ! command -v pactl >/dev/null 2>&1; then
    return 1
  fi
  return 0
}

audio_switch_start_for_pid() {
  local pid=$1

  if ! audio_switch_can_run; then
    return 0
  fi

  local original
  original=$(get_default_sink)
  if [[ -z "$original" ]]; then
    print_warn "Could not determine current default sink; skipping audio switch."
    return 0
  fi

  if [[ "$original" == "$AUDIO_SINK_NAME" ]]; then
    return 0
  fi

  if ! pactl list short sinks 2>/dev/null | awk '{print $2}' | grep -qx "$AUDIO_SINK_NAME"; then
    print_warn "Configured audio sink '$AUDIO_SINK_NAME' not found; skipping audio switch."
    return 0
  fi

  print_info "Switching default audio sink: $original -> $AUDIO_SINK_NAME"
  if ! pactl set-default-sink "$AUDIO_SINK_NAME" 2>/dev/null; then
    print_warn "Failed to switch default sink; leaving audio unchanged."
    return 0
  fi

  mkdir -p "$CONFIG_DIR"
  cat >"$AUDIO_STATE_FILE" <<EOF
AUDIO_ACTIVE=1
AUDIO_ORIGINAL_SINK=$original
AUDIO_TARGET_SINK=$AUDIO_SINK_NAME
EOF

  (
    trap 'pactl set-default-sink "$original" >/dev/null 2>&1 || true; rm -f "$AUDIO_STATE_FILE"' EXIT TERM INT

    while kill -0 "$pid" 2>/dev/null; do
      sleep 1
    done
    print_info "Restoring default audio sink to $original"
    pactl set-default-sink "$original" >/dev/null 2>&1 || true
    rm -f "$AUDIO_STATE_FILE"
  ) &

  disown 2>/dev/null || true
}

audio_restore_from_state() {
  if ! command -v pactl >/dev/null 2>&1; then
    return 0
  fi

  if [[ ! -f "$AUDIO_STATE_FILE" ]]; then
    return 0
  fi

  if [[ ! -r "$AUDIO_STATE_FILE" ]] || [[ ! -s "$AUDIO_STATE_FILE" ]]; then
    print_warn "Audio state file exists but is not readable or empty"
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  # shellcheck source=/dev/null
  . "$AUDIO_STATE_FILE"

  local original="${AUDIO_ORIGINAL_SINK:-}"
  local target="${AUDIO_TARGET_SINK:-}"

  if [[ -z "$original" || -z "$target" ]]; then
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  local current
  current=$(get_default_sink)
  if [[ -z "$current" ]]; then
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  if [[ "$current" != "$target" ]]; then
    rm -f "$AUDIO_STATE_FILE"
    return 0
  fi

  print_info "Restoring default audio sink to $original (via smtty -k)"
  pactl set-default-sink "$original" >/dev/null 2>&1 || true
  rm -f "$AUDIO_STATE_FILE"
}

run_pre_hook() {
  if [[ -z "${PRE_CMD:-}" ]]; then
    return 0
  fi

  print_info "Running pre-command (async)..."
  sh -c "$PRE_CMD" &
  disown 2>/dev/null || true
}

run_post_hook() {
  if [[ -n "${POST_CMD:-}" ]]; then
    print_info "Running post-command..."
    if ! sh -c "$POST_CMD"; then
      print_warn "Post-command failed."
    fi
  fi
}

on_gamescope_exit() {
  local pid=$1

  audio_restore_from_state

  if post_already_ran_for_pid "$pid"; then
    clear_session_state_if_pid_matches "$pid"
    return 0
  fi

  run_post_hook
  mark_post_ran_for_pid "$pid"
  clear_session_state_if_pid_matches "$pid"
  return 0
}

print_steam_launch_options() {
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config; run 'smtty -n -O' first."
    exit 1
  fi

  echo "Steam per-game launch options generator"
  if [[ -n "$CURRENT_PROFILE" ]]; then
    echo "Using profile: $CURRENT_PROFILE"
  fi
  echo

  echo "Enter your current Steam launch options for this game."
  echo "Example: gamemoderun %command% -novid +fps_max 0 -high -dx12"
  local CURRENT_LAUNCH_OPTS
  if ! backable_read CURRENT_LAUNCH_OPTS "Current launch options (empty = just %command%, b = back): "; then
    echo "Aborting launch options generator."
    exit 0
  fi

  if [[ -z "$CURRENT_LAUNCH_OPTS" ]]; then
    CURRENT_LAUNCH_OPTS='%command%'
  else
    if [[ "$CURRENT_LAUNCH_OPTS" != *"%command%"* ]]; then
      echo "Note: your launch options did not contain %command%; appending at the end."
      CURRENT_LAUNCH_OPTS="$CURRENT_LAUNCH_OPTS %command%"
    fi
  fi

  echo

  local use_flatpak_prefix=0
  local ans

  if [[ "${STEAM_TYPE:-native}" == "flatpak" ]]; then
    echo "smtty config detected Steam Flatpak."
    if ! backable_read ans "Prefix with 'flatpak-spawn --host' for this game? [Y/n, b = back]: "; then
      echo "Aborting launch options generator."
      exit 0
    fi
    case "$ans" in
      [nN]*) use_flatpak_prefix=0 ;;
      *)     use_flatpak_prefix=1 ;;
    esac
  else
    if ! backable_read ans "Is this game using Steam Flatpak? [y/N, b = back]: "; then
      echo "Aborting launch options generator."
      exit 0
    fi
    case "$ans" in
      [yY]*) use_flatpak_prefix=1 ;;
      *)     use_flatpak_prefix=0 ;;
    esac
  fi

  echo

  local use_steam_integration=0
  echo "Steam overlay / integration mode for this game:"
  if ! prompt_select "Choose integration mode" \
    "No special Steam integration (no -e; more compatible, overlay may be weaker)" \
    "Steam integration (-e; tighter overlay wiring, can break some setups)"; then
    echo "Aborting launch options generator."
    exit 0
  fi
  case "$REPLY" in
    2) use_steam_integration=1 ;;
    *) use_steam_integration=0 ;;
  esac

  echo

  detect_session_mode

  local args=()
  args+=(-f)
  args+=(-W "$NATIVE_W" -H "$NATIVE_H")
  args+=(-w "$GAME_W" -h "$GAME_H")

  if [[ "$SESSION_MODE" == "kms" && -n "$DRM_SHORT" ]]; then
    args+=(-O "$DRM_SHORT")
  fi

  if (( G_FPS > 0 )); then
    args+=(-r "$G_FPS")
  fi

  if (( G_FPS_BG > 0 )); then
    args+=(-o "$G_FPS_BG")
  fi

  if [[ "$STRETCH_FLAG" == "stretch" ]]; then
    args+=(-S stretch)
  fi

  local enable_multi_xwayland=0
  if (( GAME_W == NATIVE_W && GAME_H == NATIVE_H )) && [[ "$STRETCH_FLAG" != "stretch" ]]; then
    enable_multi_xwayland=1
    if (( SMTTY_MULTI_XWAYLAND_OK )); then  # smtty gpu compat
      args+=(--xwayland-count 2)
    fi
  fi

  if (( ADAPTIVE_SYNC == 1 )); then
    args+=(--adaptive-sync)
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )); then
    args+=(--hdr-enabled --hdr-itm-enable --hdr-itm-target-nits "$GAMESCOPE_HDR_NITS")
  fi

  if (( FORCE_GRAB_CURSOR == 1 )); then
    args+=(--force-grab-cursor)
  fi

  local env_prefix=""
  if (( enable_multi_xwayland )); then
    if (( SMTTY_MULTI_XWAYLAND_OK )); then  # smtty gpu compat
      env_prefix+="STEAM_MULTIPLE_XWAYLANDS=1 "
    fi
  fi
  if (( LOW_LATENCY_TEARING == 1 )) && [[ "$SESSION_MODE" == "kms" ]]; then
    env_prefix+="STEAM_GAMESCOPE_TEARING_SUPPORTED=1 STEAM_GAMESCOPE_HAS_TEARING_SUPPORT=1 GAMESCOPE_ALLOW_TEARING=1 "
  fi
  if [[ "${PIPEWIRE_DEBUG_MODE:-2}" != "inherit" ]]; then
    env_prefix+="PIPEWIRE_DEBUG=$PIPEWIRE_DEBUG_MODE "
  fi
  if [[ "${LD_PRELOAD_MODE:-inherit}" == "clear" ]]; then
    env_prefix+='LD_PRELOAD="" '
  fi

  if (( use_flatpak_prefix )) && have_nvidia_gpu; then
    local _p
    _p="$(resolve_flatpak_nvidia_gbm_backends_path || true)"
    if [[ -n "$_p" ]]; then
      env_prefix+="GBM_BACKENDS_PATH=$_p "
    fi
  fi

  # HDR + Wayland session -> add Proton HDR envs to the launch options
  # This is Proton-side, not gamescope-side.
  if (( ENABLE_GAMESCOPE_HDR == 1 )) && [[ -n "${WAYLAND_DISPLAY-}" ]]; then
    env_prefix+="PROTON_ENABLE_WAYLAND=1 PROTON_ENABLE_HDR=1 "
  fi

  echo "Generated Steam launch options (nested gamescope, no Gamepad UI):"
  echo

  printf '%s' "$env_prefix"
  if (( use_flatpak_prefix )); then
    printf 'flatpak-spawn --host '
  fi
  printf 'gamescope'
  if (( use_steam_integration )); then
    printf ' -e'
  fi
  printf ' %q' "${args[@]}"
  printf ' -- %s\n' "$CURRENT_LAUNCH_OPTS"

  echo
  echo "Paste the above line into this game's Steam \"Launch Options\"."
}

# ---------------- Steam launch mode (Gamepad UI vs Desktop + PIPE) ----------------

choose_steam_launch_mode() {
  # No interactive prompt.
  # Profiles default to Steam Gamepad UI (Big Picture) inside gamescope.
  # Desktop Steam + per-game gamescope is still supported via -P/-PIPE:
  #   smtty -c <profile> -P -- %command%
  STEAM_LAUNCH_MODE="gamepad"
  return 0
}


print_pipe_instructions() {
  local prof="${CURRENT_PROFILE:-}"
  [[ -z "$prof" ]] && prof="default"

  echo
  echo "Desktop Steam + PIPE mode selected."
  echo "Set this game's Steam Launch Options to:"
  if [[ "${STEAM_TYPE:-native}" == "flatpak" ]]; then
    echo "  flatpak-spawn --host smtty -c ${prof} -PIPE -- %command%"
  else
    echo "  smtty -c ${prof} -PIPE -- %command%"
  fi
  echo
  echo "Notes:"
  echo "  - Steam stays outside gamescope; only the game runs in gamescope."
  echo "  - In PIPE mode, Steam overlay behavior can vary per game/setup."
  echo
}

print_pipe_launch_options() {
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config loaded. Run: smtty -n"
    exit 1
  fi

  local prof="${CURRENT_PROFILE:-}"
  [[ -z "$prof" ]] && prof="default"

  echo "Generated Steam launch options (PIPE mode):"
  echo
  if [[ "${STEAM_TYPE:-native}" == "flatpak" ]]; then
    echo "flatpak-spawn --host smtty -c ${prof} -PIPE -- %command%"
  else
    echo "smtty -c ${prof} -PIPE -- %command%"
  fi
  echo
}

launch_gamescope_payload() {
  # Wrap the provided command in gamescope using the currently loaded profile settings.
  local -a inner_cmd=("$@")

  # SMTTY_MANGOHUD_WRAP_PAYLOAD
  if (( FLAG_MANGOHUD )); then
    if [[ "${inner_cmd[0]:-}" != "mangohud" ]]; then
      inner_cmd=(mangohud --dlsym "${inner_cmd[@]}")
    fi
  fi

  local args=()
  args+=(-f)

  # Optional: enable gamescope Steam integration (-e) in PIPE mode
  # Export before running Steam launch options if you want it:
  #   SMTTY_PIPE_STEAM_INTEGRATION=1
  if [[ "${SMTTY_PIPE_STEAM_INTEGRATION:-0}" == "1" ]]; then
    args+=(-e)
  fi

  args+=(-W "$NATIVE_W" -H "$NATIVE_H")
  args+=(-w "$GAME_W" -h "$GAME_H")

  if [[ "$SESSION_MODE" == "kms" && -n "$DRM_SHORT" ]]; then
    args+=(-O "$DRM_SHORT")
  fi

  if (( G_FPS > 0 )); then
    args+=(-r "$G_FPS")
  fi

  if (( G_FPS_BG > 0 )); then
    args+=(-o "$G_FPS_BG")
  fi

  if [[ "$STRETCH_FLAG" == "stretch" ]]; then
    args+=(-S stretch)
  fi

  local enable_multi_xwayland=0
  if (( GAME_W == NATIVE_W && GAME_H == NATIVE_H )) && [[ "$STRETCH_FLAG" != "stretch" ]]; then
    enable_multi_xwayland=1
    if (( SMTTY_MULTI_XWAYLAND_OK )); then  # smtty gpu compat
      args+=(--xwayland-count 2)
    fi
  fi

  if (( ADAPTIVE_SYNC == 1 )); then
    args+=(--adaptive-sync)
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )); then
    args+=(--hdr-enabled --hdr-itm-enable --hdr-itm-target-nits "$GAMESCOPE_HDR_NITS")
  fi

  if (( FORCE_GRAB_CURSOR == 1 )); then
    args+=(--force-grab-cursor)
  fi

  maybe_set_flatpak_nvidia_gbm_env
  run_pre_hook

  # Apply output-tied GPU env fixups and optional perf/latency presets
  smtty_apply_gpu_env_fixups
  smtty_apply_pipewire_latency_env
  smtty_apply_perf_env_preset


  if (( LOW_LATENCY_TEARING == 1 )) && [[ "$SESSION_MODE" == "kms" ]]; then
    export STEAM_GAMESCOPE_TEARING_SUPPORTED=1
    export STEAM_GAMESCOPE_HAS_TEARING_SUPPORT=1
    export GAMESCOPE_ALLOW_TEARING=1
  fi

  if [[ "${PIPEWIRE_DEBUG_MODE:-2}" != "inherit" ]]; then
    export PIPEWIRE_DEBUG="$PIPEWIRE_DEBUG_MODE"
  fi

  if [[ "${LD_PRELOAD_MODE:-inherit}" == "clear" ]]; then
    export LD_PRELOAD=""
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )) && [[ -n "${WAYLAND_DISPLAY-}" ]]; then
    export PROTON_ENABLE_WAYLAND=1
    export PROTON_ENABLE_HDR=1
  fi

  local -a gs_exec=(gamescope)
  if (( enable_multi_xwayland )); then
    if (( SMTTY_MULTI_XWAYLAND_OK )); then  # smtty gpu compat
      gs_exec=(env STEAM_MULTIPLE_XWAYLANDS=1 gamescope)
    fi
  fi

  echo "PIPE mode command:"
  if (( enable_multi_xwayland )); then
    printf '%s' 'STEAM_MULTIPLE_XWAYLANDS=1 '
  fi
  if (( LOW_LATENCY_TEARING == 1 )) && [[ "$SESSION_MODE" == "kms" ]]; then
    printf '%s' 'STEAM_GAMESCOPE_TEARING_SUPPORTED=1 STEAM_GAMESCOPE_HAS_TEARING_SUPPORT=1 GAMESCOPE_ALLOW_TEARING=1 '
  fi
  printf '%s' 'gamescope'
  printf ' %q' "${args[@]}"
  printf ' --'
  printf ' %q' "${inner_cmd[@]}"
  printf '\n\n'

  local gspid=0
  local gs_status=0

  trap 'if [[ "$gspid" =~ ^[0-9]+$ ]] && (( gspid > 0 )); then kill -TERM "$gspid" 2>/dev/null || true; fi' INT TERM

  "${gs_exec[@]}" "${args[@]}" -- "${inner_cmd[@]}" &
  gspid=$!

  # SMTTY_HYPR_FOCUS_AFTER_LAUNCH_BEGIN
  if [[ "$SESSION_MODE" == "nested" ]]; then
    smtty_hypr_focus_gamescope_pid "$gspid" || true
  fi
  # SMTTY_HYPR_FOCUS_AFTER_LAUNCH_END

  write_session_state "$gspid"
  audio_switch_start_for_pid "$gspid"

  if ! wait "$gspid"; then
    gs_status=$?
  fi

  trap - INT TERM

  on_gamescope_exit "$gspid"
  return "$gs_status"
}

# SMTTY_GAMEPADUI_PIPE_HELPER_BEGIN
smtty_in_gamepadui_session() {
  # True when smtty is launched from Steam Gamepad UI running inside gamescope.
  # Used to bypass -P to avoid recursive/nested gamescope/profile handling.
  local pid depth
  local seen_steam=0
  local seen_gamescope=0

  # Optional explicit override from the outer smtty session.
  if [[ "${SMTTY_GAMEPADUI_SESSION:-0}" == "1" ]]; then
    return 0
  fi

  pid="${PPID:-0}"
  depth=0

  while [[ "$pid" =~ ^[0-9]+$ ]] && (( pid > 1 )) && (( depth < 64 )); do
    local cmdline ppid
    cmdline="$(tr '\0' ' ' <"/proc/${pid}/cmdline" 2>/dev/null || true)"

    if [[ "$cmdline" == *gamescope* ]]; then
      seen_gamescope=1
    fi

    if [[ "$cmdline" == *steam* ]] && { [[ "$cmdline" == *" -gamepadui"* ]] || [[ "$cmdline" == *" -tenfoot"* ]]; }; then
      seen_steam=1
    fi

    if (( seen_gamescope == 1 && seen_steam == 1 )); then
      return 0
    fi

    ppid="$(awk '{print $4}' "/proc/${pid}/stat" 2>/dev/null || echo 0)"
    pid="$ppid"
    ((depth++))
  done

  return 1
}
# SMTTY_GAMEPADUI_PIPE_HELPER_END

run_pipe_mode() {
  # SMTTY_GAMEPADUI_PIPE_GUARD_BEGIN
  if [[ "${SMTTY_PIPE_GUARD_DISABLE:-0}" != "1" ]] && smtty_in_gamepadui_session; then
    local -a wrapped_cmd=()
    local a
    local found=0

    for a in "$@"; do
      if (( found == 0 )); then
        if [[ "$a" == "--" ]]; then
          found=1
        fi
        continue
      fi
      wrapped_cmd+=("$a")
    done

    if (( found == 0 )); then
      wrapped_cmd=("$@")
    fi

    if (( ${#wrapped_cmd[@]} == 0 )); then
      echo "[ERROR] smtty -P invoked without a command; expected: smtty ... -P -- %command%" >&2
      return 1
    fi

    exec "${wrapped_cmd[@]}"
  fi
  # SMTTY_GAMEPADUI_PIPE_GUARD_END

  # Usage from Steam Launch Options:
  #   smtty -c <profile> -PIPE -- %command%
  # Steam Flatpak:
  #   flatpak-spawn --host smtty -c <profile> -PIPE -- %command%

  if (( HAVE_CONFIG == 0 )); then
    print_error "PIPE mode requires a loaded profile. Use: smtty -c <profile> -PIPE -- %command%"
    return 1
  fi

  detect_session_mode
  init_default_refresh_for_output
  check_deps

  if [[ "${1-}" == "--" ]]; then
    shift || true
  fi

  if (( $# < 1 )); then
    print_error "PIPE mode requires a command. Use: smtty -PIPE -- %command%"
    return 2
  fi

  # Do NOT kill/stop Steam in PIPE mode.
  launch_gamescope_payload "$@"
}


# ---------------- Steam installation detection ----------------
detect_steam_installations() {
  local available=()
  local have_native=0
  local have_flatpak=0

  local df=""
  df="$(smtty_find_steam_desktop_file 2>/dev/null || true)"

  if [[ -n "$df" ]]; then
    available+=("Native Steam (steam.desktop)")
    have_native=1
  elif command -v steam >/dev/null 2>&1; then
    available+=("Native Steam (steam)")
    have_native=1
  fi

  if command -v flatpak >/dev/null 2>&1 && \
     flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
    available+=("Steam Flatpak (com.valvesoftware.Steam)")
    have_flatpak=1
  fi

  if (( ${#available[@]} == 0 )); then
    print_error "No Steam installation found."
    echo "Please install Steam (native) or Steam Flatpak."
    return 1
  fi

  if (( ${#available[@]} == 1 )); then
    if (( have_native )); then
      STEAM_TYPE="native"
      print_info "Detected: Native Steam"
    elif (( have_flatpak )); then
      STEAM_TYPE="flatpak"
      print_info "Detected: Steam Flatpak"
    else
      print_error "Internal error: Unknown Steam type despite one available."
      return 1
    fi
    echo
    return 0
  fi

  echo "Multiple Steam installations detected:"
  if ! prompt_select "Choose Steam installation" "${available[@]}"; then
    return 1
  fi

  if (( REPLY == 1 )); then
    STEAM_TYPE="native"
  else
    STEAM_TYPE="flatpak"
  fi

  echo
  echo "Using: ${available[REPLY-1]}"
  echo
  return 0
}


# smtty-patch: native steam.desktop launcher
# Prefer launching native Steam via steam.desktop Exec= when available.
SMTTY_NATIVE_STEAM_ARR=()

smtty_find_steam_desktop_file() {
  local p
  for p in "$HOME/.local/share/applications/steam.desktop" "/usr/share/applications/steam.desktop"; do
    if [[ -r "$p" ]]; then
      printf "%s\n" "$p"
      return 0
    fi
  done
  return 1
}

smtty_read_desktop_exec() {
  local f="${1:?missing .desktop path}"
  awk '
    BEGIN{in=0}
    /^\[Desktop Entry\]/{in=1;next}
    /^\[/{if(in) exit}
    in && /^Exec=/{sub(/^Exec=/,""); print; exit}
  ' "$f"
}

smtty_strip_desktop_field_codes() {
  # Remove Desktop Entry field codes: %U %u %F %f %i %c %k etc.
  # Keep literal %% intact.
  sed -E 's/[[:space:]]+%[a-zA-Z]//g; s/%[a-zA-Z]//g'
}

smtty_native_steam_cmd_arr() {
  # Sets SMTTY_NATIVE_STEAM_ARR to the base Steam command (no -gamepadui appended).
  SMTTY_NATIVE_STEAM_ARR=()

  local df exec
  df="$(smtty_find_steam_desktop_file 2>/dev/null || true)"
  if [[ -n "$df" ]]; then
    exec="$(smtty_read_desktop_exec "$df" 2>/dev/null || true)"
    if [[ -z "$exec" ]]; then
      return 1
    fi
    exec="$(printf "%s" "$exec" | smtty_strip_desktop_field_codes)"
    exec="${exec# }"
    exec="${exec% }"
    if [[ -z "$exec" ]]; then
      return 1
    fi
    read -r -a SMTTY_NATIVE_STEAM_ARR <<<"$exec"
    if (( ${#SMTTY_NATIVE_STEAM_ARR[@]} == 0 )); then
      return 1
    fi
    return 0
  fi

  if command -v steam >/dev/null 2>&1; then
    SMTTY_NATIVE_STEAM_ARR=(steam)
    return 0
  fi

  return 1
}

configure_steam_command() {
  if [[ -n "${STEAM_CMD_OVERRIDE-}" ]]; then
    return
  fi

  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    STEAM_CMD_ARR=(flatpak run com.valvesoftware.Steam -gamepadui)
    return
  fi

  # Native Steam: prefer steam.desktop Exec=, fall back to steam in PATH.
  if smtty_native_steam_cmd_arr; then
    STEAM_CMD_ARR=("${SMTTY_NATIVE_STEAM_ARR[@]}")
  else
    STEAM_CMD_ARR=(steam)
  fi

  # Ensure -gamepadui is present for the in-gamescope Steam session.
  case " ${STEAM_CMD_ARR[*]} " in
    *" -gamepadui "*) ;;
    *) STEAM_CMD_ARR+=(-gamepadui) ;;
  esac
}

require_cmd() {
  local cmd=$1
  if ! command -v "$cmd" >/dev/null 2>&1; then
    MISSING_CMDS+=("$cmd")
  fi
}

# ---------------- distro-aware dependency guidance ----------------
PKG_MGR="unknown"

is_ostree_system() {
  [[ -e /run/ostree-booted ]] || command -v rpm-ostree >/dev/null 2>&1
}

detect_pkg_manager() {
  if is_ostree_system; then
    PKG_MGR="rpm-ostree"
  elif command -v apt-get >/dev/null 2>&1; then
    PKG_MGR="apt"
  elif command -v dnf >/dev/null 2>&1; then
    PKG_MGR="dnf"
  elif command -v pacman >/dev/null 2>&1; then
    PKG_MGR="pacman"
  elif command -v zypper >/dev/null 2>&1; then
    PKG_MGR="zypper"
  else
    PKG_MGR="unknown"
  fi
}

pkg_for_cmd() {
  local cmd=$1

  case "$PKG_MGR" in
    apt)
      case "$cmd" in
        gamescope) echo "gamescope" ;;
        steam)     echo "steam" ;;
        flatpak)   echo "flatpak" ;;
        pgrep|pkill|ps) echo "procps" ;;
        awk)       echo "gawk" ;;
        grep)      echo "grep" ;;
        find)      echo "findutils" ;;
        sort|tail|head|tr|cat) echo "coreutils" ;;
        script|setsid) echo "util-linux" ;;
        pactl)     echo "pulseaudio-utils" ;;
        modetest)  echo "libdrm-tests" ;;
        mangohud)  echo "mangohud" ;;
        *)         echo "" ;;
      esac
      ;;
    dnf|rpm-ostree)
      case "$cmd" in
        gamescope) echo "gamescope" ;;
        steam)     echo "steam" ;;
        flatpak)   echo "flatpak" ;;
        pgrep|pkill|ps) echo "procps-ng" ;;
        awk)       echo "gawk" ;;
        grep)      echo "grep" ;;
        find)      echo "findutils" ;;
        sort|tail|head|tr|cat) echo "coreutils" ;;
        script|setsid) echo "util-linux" ;;
        pactl)     echo "pulseaudio-utils" ;;
        modetest)  echo "drm-utils" ;;
        mangohud)  echo "mangohud" ;;
        *)         echo "" ;;
      esac
      ;;
    pacman)
      case "$cmd" in
        gamescope) echo "gamescope" ;;
        steam)     echo "steam" ;;
        flatpak)   echo "flatpak" ;;
        pgrep|pkill|ps) echo "procps-ng" ;;
        awk)       echo "gawk" ;;
        grep)      echo "grep" ;;
        find)      echo "findutils" ;;
        sort|tail|head|tr|cat) echo "coreutils" ;;
        script|setsid) echo "util-linux" ;;
        pactl)     echo "libpulse" ;;
        modetest)  echo "libdrm" ;;
        mangohud)  echo "mangohud" ;;
        *)         echo "" ;;
      esac
      ;;
    zypper)
      case "$cmd" in
        gamescope) echo "gamescope" ;;
        steam)     echo "steam" ;;
        flatpak)   echo "flatpak" ;;
        pgrep|pkill|ps) echo "procps" ;;
        awk)       echo "gawk" ;;
        grep)      echo "grep" ;;
        find)      echo "findutils" ;;
        sort|tail|head|tr|cat) echo "coreutils" ;;
        script|setsid) echo "util-linux" ;;
        pactl)     echo "pulseaudio-utils" ;;
        modetest)  echo "libdrm-tools" ;;
        mangohud)  echo "mangohud" ;;
        *)         echo "" ;;
      esac
      ;;
    *)
      echo ""
      ;;
  esac
}

flatpak_steam_installed() {
  command -v flatpak >/dev/null 2>&1 || return 1
  flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"
}

build_one_install_command() {
  # Usage: build_one_install_command <need_flatpak_steam_app 0/1> <missing_cmd_1> ...
  local need_flatpak_steam_app=${1:-0}
  shift || true

  detect_pkg_manager

  local -A seen=()
  local -a pkgs=()
  local cmd pkg

  for cmd in "$@"; do
    pkg="$(pkg_for_cmd "$cmd")"
    [[ -n "$pkg" ]] || continue
    [[ -n "${seen[$pkg]-}" ]] && continue
    seen["$pkg"]=1
    pkgs+=("$pkg")
  done

  local host_install=""
  case "$PKG_MGR" in
    apt)
      if (( ${#pkgs[@]} > 0 )); then
        host_install="sudo apt update && sudo apt install -y ${pkgs[*]}"
      fi
      ;;
    dnf)
      if (( ${#pkgs[@]} > 0 )); then
        host_install="sudo dnf install -y ${pkgs[*]}"
      fi
      ;;
    pacman)
      if (( ${#pkgs[@]} > 0 )); then
        host_install="sudo pacman -Syu --needed ${pkgs[*]}"
      fi
      ;;
    zypper)
      if (( ${#pkgs[@]} > 0 )); then
        host_install="sudo zypper install -y ${pkgs[*]}"
      fi
      ;;
    rpm-ostree)
      if (( ${#pkgs[@]} > 0 )); then
        host_install="sudo rpm-ostree install ${pkgs[*]} && systemctl reboot"
      fi
      ;;
    *)
      host_install=""
      ;;
  esac

  local fp_install=""
  if (( need_flatpak_steam_app )); then
    fp_install="flatpak install -y flathub com.valvesoftware.Steam"
  fi

  if [[ "$PKG_MGR" == "rpm-ostree" ]]; then
    if [[ -n "$fp_install" && -n "$host_install" ]]; then
      printf '%s; %s\n' "$fp_install" "$host_install"
    elif [[ -n "$fp_install" ]]; then
      printf '%s\n' "$fp_install"
    elif [[ -n "$host_install" ]]; then
      printf '%s\n' "$host_install"
    else
      printf '%s\n' ""
    fi
    return 0
  fi

  if [[ -n "$fp_install" && -n "$host_install" ]]; then
    printf '%s && %s\n' "$host_install" "$fp_install"
  elif [[ -n "$host_install" ]]; then
    printf '%s\n' "$host_install"
  elif [[ -n "$fp_install" ]]; then
    printf '%s\n' "$fp_install"
  else
    printf '%s\n' ""
  fi
}

# ---------------- gamescope deps ----------------
check_deps() {
  MISSING_CMDS=()

  # Required shell/userland tools used throughout the script.
  require_cmd awk
  require_cmd grep
  require_cmd find
  require_cmd sort
  require_cmd tail
  require_cmd head
  require_cmd tr
  require_cmd cat

  # Process tools used by the script (steam/gamescope control).
  require_cmd pgrep
  require_cmd pkill
  require_cmd ps

  # Hard required for launching.
  require_cmd gamescope

  if (( FLAG_MANGOHUD )); then
    require_cmd mangohud
  fi

  local need_flatpak_steam_app=0

  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    require_cmd flatpak
    if command -v flatpak >/dev/null 2>&1; then
      if ! flatpak_steam_installed; then
        need_flatpak_steam_app=1
      fi
    fi
  else
    require_cmd steam

  # smtty-patch: native steam.desktop launcher (deps)
  # If `steam` is not in PATH but steam.desktop exists, do not hard-fail deps.
  if [[ "$STEAM_TYPE" != "flatpak" ]] && ! command -v steam >/dev/null 2>&1; then
    if smtty_find_steam_desktop_file >/dev/null 2>&1; then
      local _filtered=()
      local _c
      for _c in "${MISSING_CMDS[@]}"; do
        [[ "$_c" == "steam" ]] || _filtered+=("$_c")
      done
      MISSING_CMDS=("${_filtered[@]}")
    fi
  fi

  fi

  # Soft deps (feature degradation only).
  local -a SOFT_MISSING=()
  command -v modetest >/dev/null 2>&1 || SOFT_MISSING+=("modetest")
  command -v pactl    >/dev/null 2>&1 || SOFT_MISSING+=("pactl")
  command -v script   >/dev/null 2>&1 || SOFT_MISSING+=("script")
  command -v setsid   >/dev/null 2>&1 || SOFT_MISSING+=("setsid")

  command -v edid-decode >/dev/null 2>&1 || SOFT_MISSING+=("edid-decode")
  if ((${#MISSING_CMDS[@]} > 0)) || (( need_flatpak_steam_app )); then
    print_error "Missing required dependencies:"
    if ((${#MISSING_CMDS[@]} > 0)); then
      printf '  - %s\n' "${MISSING_CMDS[@]}"
    fi
    if (( need_flatpak_steam_app )); then
      printf '  - %s\n' "Steam Flatpak app (com.valvesoftware.Steam)"
    fi
    echo

    local cmdline
    cmdline="$(build_one_install_command "$need_flatpak_steam_app" "${MISSING_CMDS[@]}")"

    if [[ -n "$cmdline" ]]; then
      print_info "Install command (single line):"
      echo "  $cmdline"
      echo
      if is_ostree_system; then
        print_warn "Immutable (rpm-ostree) systems may require a reboot after layering packages."
        echo
      fi
    else
      print_warn "Could not detect your package manager to generate an install command."
      print_info "Install the missing tools with your distro's package manager, then re-run smtty."
      echo
    fi

    exit 1
  fi

  if ((${#SOFT_MISSING[@]} > 0)); then
    print_warn "Optional tools missing (some features degrade):"
    printf '  - %s\n' "${SOFT_MISSING[@]}"
    echo
  fi
}

steam_is_running() {
  pgrep -x steam >/dev/null 2>&1
}

# smtty-patch: desktop Steam launcher for PIPE mode
smtty_spawn_detached() {
  # usage: smtty_spawn_detached <cmd...>
  if command -v setsid >/dev/null 2>&1; then
    setsid "$@" >/dev/null 2>&1 < /dev/null &
  else
    nohup "$@" >/dev/null 2>&1 < /dev/null &
  fi
  disown 2>/dev/null || true
}

desktop_steam_is_running() {
  # Detect either native steam or Flatpak Steam.
  pgrep -x steam >/dev/null 2>&1 && return 0
  pgrep -f 'com\.valvesoftware\.Steam' >/dev/null 2>&1 && return 0
  return 1
}

smtty_find_native_steam_desktop_file() {
  if [[ -f "$HOME/.local/share/applications/steam.desktop" ]]; then
    printf '%s\n' "$HOME/.local/share/applications/steam.desktop"
    return 0
  fi
  if [[ -f "/usr/share/applications/steam.desktop" ]]; then
    printf '%s\n' "/usr/share/applications/steam.desktop"
    return 0
  fi
  return 1
}

smtty_launch_desktop_steam_native() {
  local df=""
  df="$(smtty_find_native_steam_desktop_file 2>/dev/null || true)"

  # Prefer gtk-launch with the desktop id.
  if [[ -n "$df" ]] && command -v gtk-launch >/dev/null 2>&1; then
    local id="${df##*/}"
    id="${id%.desktop}"
    smtty_spawn_detached gtk-launch "$id"
    return 0
  fi

  # Fallback: parse Exec= and run it.
  if [[ -n "$df" ]] && [[ -r "$df" ]]; then
    local exec_line=""
    exec_line="$(awk -F'=' 'BEGIN{IGNORECASE=1} $1=="Exec"{print substr($0,index($0,"=")+1); exit}' "$df" 2>/dev/null || true)"
    if [[ -n "$exec_line" ]]; then
      # Strip desktop field codes.
      exec_line="${exec_line//%%/%}"
      for code in %u %U %f %F %i %c %k; do
        exec_line="${exec_line//$code/}"
      done
      # Trim leading/trailing spaces.
      exec_line="${exec_line#"${exec_line%%[![:space:]]*}"}"
      exec_line="${exec_line%"${exec_line##*[![:space:]]}"}"
      if [[ -n "$exec_line" ]]; then
        smtty_spawn_detached bash -lc "$exec_line"
        return 0
      fi
    fi
  fi

  # Last fallback: run steam directly.
  if command -v steam >/dev/null 2>&1; then
    smtty_spawn_detached steam
    return 0
  fi

  # Extra fallback: steam URI.
  if command -v xdg-open >/dev/null 2>&1; then
    smtty_spawn_detached xdg-open "steam://open/main"
    return 0
  fi

  return 1
}

smtty_launch_desktop_steam_flatpak() {
  if command -v flatpak >/dev/null 2>&1; then
    smtty_spawn_detached flatpak run com.valvesoftware.Steam
    return 0
  fi
  return 1
}

launch_desktop_steam_if_needed() {
  # Only intended for STEAM_LAUNCH_MODE=pipe.
  desktop_steam_is_running && return 0

  print_info "Launching desktop Steam (outside gamescope)..."

  if [[ "${STEAM_TYPE:-native}" == "flatpak" ]]; then
    smtty_launch_desktop_steam_flatpak && return 0
  else
    smtty_launch_desktop_steam_native && return 0
  fi

  print_warn "Could not auto-launch desktop Steam. Start Steam manually, then use PIPE Launch Options."
  return 1
}
# end smtty-patch: desktop Steam launcher for PIPE mode

request_steam_shutdown() {
  # Try native Steam first; fall back to Flatpak if present.

  if command -v steam >/dev/null 2>&1; then
    if steam -shutdown >/dev/null 2>&1; then
      return 0
    fi
  fi

  # Native fallback: steam.desktop Exec=
  if smtty_native_steam_cmd_arr; then
    if "${SMTTY_NATIVE_STEAM_ARR[@]}" -shutdown >/dev/null 2>&1; then
      return 0
    fi
  fi

  if command -v flatpak >/dev/null 2>&1; then
    if flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
      if flatpak run com.valvesoftware.Steam -shutdown >/dev/null 2>&1; then
        return 0
      fi
    fi
  fi

  return 1
}

kill_steam_client() {
  # Futureproofing:
  #   Prefer graceful shutdown first. If still alive, kill only the main client
  #   and helpers, avoiding broad "pkill steam" that can hit steamcmd, etc.

  if ! pgrep -x steam >/dev/null 2>&1; then
    echo "No Steam client processes found."
    return 0
  fi

  echo "Stopping Steam client..."
  request_steam_shutdown || true

  local i
  for ((i = 0; i < 40; i++)); do
    if ! pgrep -x steam >/dev/null 2>&1; then
      print_success "Steam client stopped."
      return 0
    fi
    sleep 0.25
  done

  print_warn "Steam still appears to be running; sending SIGTERM to steam."
  pkill -x -TERM steam >/dev/null 2>&1 || true

  for ((i = 0; i < 40; i++)); do
    if ! pgrep -x steam >/dev/null 2>&1; then
      print_success "Steam client stopped."
      return 0
    fi
    sleep 0.25
  done

  print_warn "Steam still appears to be running; terminating steamwebhelper if present."
  pkill -x -TERM steamwebhelper >/dev/null 2>&1 || true

  for ((i = 0; i < 40; i++)); do
    if ! pgrep -x steam >/dev/null 2>&1; then
      print_success "Steam client stopped."
      return 0
    fi
    sleep 0.25
  done

  print_error "Steam still appears to be running after waiting ~30 seconds."
  echo "Aborting smtty launch to avoid a broken gamescope start."
  exit 1
}

handle_running_steam_before_launch() {
  if ! steam_is_running; then
    return 0
  fi

  # -S: kill Steam without asking
  if (( FLAG_KILL_STEAM )); then
    kill_steam_client
    return 0
  fi

  # Futureproofing: -l / -c previously proceeded even if Steam was running,
  # which commonly causes confusing failures (Steam reuses existing instance).
  if (( FLAG_LAST )) || [[ -n "$SELECTED_PROFILE" ]]; then
    print_warn "Steam is already running. For -l/-c launches, use -S to stop desktop Steam first."
    echo "Aborting smtty launch to avoid a broken gamescope start."
    exit 0
  fi

  echo "Steam client is currently running."
  echo "There can only be one Steam instance at a time."
  echo "To launch Steam inside gamescope, smtty needs to stop the existing"
  echo "desktop Steam process and then relaunch Steam Gamepad UI in gamescope."
  local ans
  if ! backable_read ans "Kill desktop Steam and relaunch it inside gamescope now? [y/N, b = back]: "; then
    echo "Aborting smtty launch."
    exit 0
  fi
  case "$ans" in
    [yY])
      kill_steam_client
      ;;
    *)
      echo "Leaving existing Steam session running. Aborting smtty launch to avoid a broken gamescope start."
      exit 0
      ;;
  esac
}

# ---------------- launch ----------------

launch_vanilla_gamescope() {
  local inner_cmd=("$@")

  local args=()
  args+=(-f -e)
  args+=(-W "$NATIVE_W" -H "$NATIVE_H")
  args+=(-w "$GAME_W" -h "$GAME_H")

  if [[ "$SESSION_MODE" == "kms" && -n "$DRM_SHORT" ]]; then
    args+=(-O "$DRM_SHORT")
  fi

  if (( G_FPS > 0 )); then
    args+=(-r "$G_FPS")
  fi

  if (( G_FPS_BG > 0 )); then
    args+=(-o "$G_FPS_BG")
  fi

  if [[ "$STRETCH_FLAG" == "stretch" ]]; then
    args+=(-S stretch)
  fi

  local enable_multi_xwayland=0
  if (( GAME_W == NATIVE_W && GAME_H == NATIVE_H )) && [[ "$STRETCH_FLAG" != "stretch" ]]; then
    enable_multi_xwayland=1
    if (( SMTTY_MULTI_XWAYLAND_OK )); then  # smtty gpu compat
      args+=(--xwayland-count 2)
    fi
  fi

  if (( ADAPTIVE_SYNC == 1 )); then
    args+=(--adaptive-sync)
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )); then
    args+=(--hdr-enabled --hdr-itm-enable --hdr-itm-target-nits "$GAMESCOPE_HDR_NITS")
  fi

  if (( FORCE_GRAB_CURSOR == 1 )); then
    args+=(--force-grab-cursor)
  fi

  echo "Command:"
  if (( enable_multi_xwayland )); then
    printf 'STEAM_MULTIPLE_XWAYLANDS=1 '
  fi
  if (( LOW_LATENCY_TEARING == 1 )) && [[ "$SESSION_MODE" == "kms" ]]; then
    printf 'STEAM_GAMESCOPE_TEARING_SUPPORTED=1 STEAM_GAMESCOPE_HAS_TEARING_SUPPORT=1 GAMESCOPE_ALLOW_TEARING=1 '
  fi
  printf 'gamescope'
  printf ' %q' "${args[@]}"
  printf ' --'
  printf ' %q' "${inner_cmd[@]}"
  printf '\n\n'

  maybe_set_flatpak_nvidia_gbm_env

  run_pre_hook

  # Apply output-tied GPU env fixups and optional perf/latency presets
  smtty_apply_gpu_env_fixups
  smtty_apply_pipewire_latency_env
  smtty_apply_perf_env_preset


  if (( LOW_LATENCY_TEARING == 1 )) && [[ "$SESSION_MODE" == "kms" ]]; then
    export STEAM_GAMESCOPE_TEARING_SUPPORTED=1
    export STEAM_GAMESCOPE_HAS_TEARING_SUPPORT=1
    export GAMESCOPE_ALLOW_TEARING=1
  fi
  if [[ "${PIPEWIRE_DEBUG_MODE:-2}" != "inherit" ]]; then
    export PIPEWIRE_DEBUG="$PIPEWIRE_DEBUG_MODE"
  fi

  if [[ "${LD_PRELOAD_MODE:-inherit}" == "clear" ]]; then
    export LD_PRELOAD=""
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )) && [[ -n "${WAYLAND_DISPLAY-}" ]]; then
    export PROTON_ENABLE_WAYLAND=1
    export PROTON_ENABLE_HDR=1
  fi

  local -a gs_exec=(gamescope)
  if (( enable_multi_xwayland )); then
    if (( SMTTY_MULTI_XWAYLAND_OK )); then  # smtty gpu compat
      gs_exec=(env STEAM_MULTIPLE_XWAYLANDS=1 gamescope)
    fi
  fi

  if (( FLAG_DETACH )); then
    if command -v setsid >/dev/null 2>&1; then
      setsid "${gs_exec[@]}" "${args[@]}" -- "${inner_cmd[@]}" >/dev/null 2>&1 &
    else
      "${gs_exec[@]}" "${args[@]}" -- "${inner_cmd[@]}" >/dev/null 2>&1 &
    fi
    local gspid=$!
    audio_switch_start_for_pid "$gspid"
    write_session_state "$gspid"
    print_success "gamescope started in detached mode with PID $gspid."
    echo "Use 'smtty -k' to request Steam shutdown and end the session."
    exit 0
  fi

  mkdir -p "$CONFIG_DIR"
  local gs_log="$CONFIG_DIR/gamescope-session.$$.log"
  local gs_pid_file="$CONFIG_DIR/gamescope-session.$$.pid"
  : >"$gs_log"
  : >"$gs_pid_file"

  local gspid=0
  local marker_watch_pid=0
  local steam_child_watch_pid=0
  local desktop_spawn_watch_pid=0
  local wrapper_pid=0

  if command -v script >/dev/null 2>&1; then
    # Build a fully-quoted gamescope command string.
    local cmd_str="gamescope"
    if (( enable_multi_xwayland )); then
      if (( SMTTY_MULTI_XWAYLAND_OK )); then  # smtty gpu compat
        cmd_str="env STEAM_MULTIPLE_XWAYLANDS=1 gamescope"
      fi
    fi
    local a
    for a in "${args[@]}"; do
      cmd_str+=" $(printf '%q' "$a")"
    done
    cmd_str+=" --"
    for a in "${inner_cmd[@]}"; do
      cmd_str+=" $(printf '%q' "$a")"
    done

    local pid_file_q
    pid_file_q=$(printf '%q' "$gs_pid_file")

    # Run gamescope inside a bash wrapper that records the real PID then waits.
    local wrapper_cmd
    wrapper_cmd="bash -lc 'set -e; ${cmd_str} & echo \$! > ${pid_file_q}; wait \$!'"

    script -q -f -c "$wrapper_cmd" "$gs_log" &
    wrapper_pid=$!

    # Read the real gamescope PID from the pidfile.
    local i
    for ((i=0; i<100; i++)); do
      if [[ -s "$gs_pid_file" ]]; then
        read -r gspid <"$gs_pid_file" || true
        break
      fi
      sleep 0.05
    done

    # Fallback if pidfile failed.
    if [[ ! "$gspid" =~ ^[0-9]+$ ]] || (( gspid <= 0 )); then
      gspid=$(pgrep -n -u "$UID" -x gamescope 2>/dev/null || true)
    fi
  else
    # No script available, preserve TTY behavior by not piping output.
    "${gs_exec[@]}" "${args[@]}" -- "${inner_cmd[@]}" &
    gspid=$!
  fi

  if [[ ! "$gspid" =~ ^[0-9]+$ ]] || (( gspid <= 0 )); then
    print_warn "Could not reliably determine gamescope PID; desktop-switch auto-kill may be unreliable."
    # As a last resort, track the wrapper if we have one.
    if [[ "$wrapper_pid" =~ ^[0-9]+$ ]] && (( wrapper_pid > 0 )); then
      gspid=$wrapper_pid
    fi
  fi

  write_session_state "$gspid"
  audio_switch_start_for_pid "$gspid"

  marker_watch_pid=$(start_desktop_switch_watcher "$gs_log" "$gspid" || echo 0)
  steam_child_watch_pid=$(start_steam_child_exit_watcher "$gspid" || echo 0)
  desktop_spawn_watch_pid=$(start_desktop_steam_spawn_watcher "$gspid" || echo 0)

  # Futureproofing:
  #   If we launched via `script`, the real gamescope PID is not a child of this shell.
  #   Waiting on it can fail. Wait on the `script` wrapper process instead.
  local gs_status=0
  if [[ "$wrapper_pid" =~ ^[0-9]+$ ]] && (( wrapper_pid > 0 )); then
    if ! wait "$wrapper_pid"; then
      gs_status=$?
    fi
  else
    if ! wait "$gspid"; then
      gs_status=$?
    fi
  fi

  if [[ "$marker_watch_pid" =~ ^[0-9]+$ ]] && (( marker_watch_pid > 0 )); then
    kill "$marker_watch_pid" 2>/dev/null || true
  fi
  if [[ "$steam_child_watch_pid" =~ ^[0-9]+$ ]] && (( steam_child_watch_pid > 0 )); then
    kill "$steam_child_watch_pid" 2>/dev/null || true
  fi
  if [[ "$desktop_spawn_watch_pid" =~ ^[0-9]+$ ]] && (( desktop_spawn_watch_pid > 0 )); then
    kill "$desktop_spawn_watch_pid" 2>/dev/null || true
  fi

  rm -f "$gs_log" "$gs_pid_file" 2>/dev/null || true

  on_gamescope_exit "$gspid"
  exit "$gs_status"
}

launch_gamescope_session() {
  # $1 == 1 means this came from the main menu and "b" should return there.
  configure_steam_command
  check_deps

  local inner_cmd=()
  local inner_label="Steam Gamepad UI (Big Picture)"

  inner_cmd=("${STEAM_CMD_ARR[@]}")

  # SMTTY_MANGOHUD_WRAP_SESSION
  if (( FLAG_MANGOHUD )); then
    if [[ "${inner_cmd[0]:-}" != "mangohud" ]]; then
      inner_cmd=(mangohud --dlsym "${inner_cmd[@]}")
    fi
  fi


  # CLI payload after `--`:
  # If provided, treat it as additional Steam args for the in-gamescope Steam session.
  # (For arbitrary commands inside gamescope, use -P/-PIPE.)
  local cli_args_used=0
  if (( ${#SMTTY_CLI_PAYLOAD[@]} > 0 )); then
    local -a extra=("${SMTTY_CLI_PAYLOAD[@]}")

    # Strip common Steam invocations if the user included them.
    if [[ "${extra[0]}" == "steam" || "${extra[0]}" == */steam ]]; then
      extra=("${extra[@]:1}")
    elif [[ "${extra[0]}" == "flatpak" ]]; then
      if (( ${#extra[@]} >= 3 )) && [[ "${extra[1]}" == "run" && "${extra[2]}" == "com.valvesoftware.Steam" ]]; then
        extra=("${extra[@]:3}")
      fi
    fi

    # Only accept obvious Steam arguments here.
    if (( ${#extra[@]} > 0 )); then
      case "${extra[0]}" in
        -*|steam://*)
          inner_cmd+=("${extra[@]}")
          inner_label+=" (CLI args)"
          cli_args_used=1
          ;;
        *)
          print_warn "Ignoring CLI payload after '--' in Gamepad UI mode (not a Steam arg). Use -P/-PIPE for arbitrary commands."
          ;;
      esac
    fi
  fi


  # Auto-launch selected Steam game (from main menu picker) inside this Steam session.
  if (( cli_args_used == 0 )) && [[ -n "${SMTTY_APPLAUNCH_APPID:-}" ]]; then
    inner_cmd+=(-applaunch "$SMTTY_APPLAUNCH_APPID")
    if [[ -n "${SMTTY_APPLAUNCH_NAME:-}" ]]; then
      inner_label+=" (auto-launch: ${SMTTY_APPLAUNCH_NAME})"
    else
      inner_label+=" (auto-launch appid ${SMTTY_APPLAUNCH_APPID})"
    fi
  fi

  echo
  echo "Launching gamescope:"
  if [[ -n "$CURRENT_PROFILE" ]]; then
    echo "  Profile:               $CURRENT_PROFILE"
  fi
  echo "  Session mode:          $SESSION_MODE (kms = bare VT, nested = under compositor)"
  echo "  Steam type:            ${STEAM_TYPE:-native}"
  echo "  DRM output:            $DRM_SHORT"
  echo "  Outer (panel/native):  ${NATIVE_W}x${NATIVE_H}"
  echo "  Inner (game):          ${GAME_W}x${GAME_H}"
  echo "  Stretch mode:          ${STRETCH_FLAG}"
  echo "  Target refresh:        ${G_FPS} Hz (0 = auto-detect max via modetest; else unlimited)"
  echo "  Unfocused refresh:     ${G_FPS_BG} Hz (gamescope -o, 0 = disabled / omitted)"
  echo "  Adaptive sync (VRR):   ${ADAPTIVE_SYNC}"
  echo "  HDR enabled:           ${ENABLE_GAMESCOPE_HDR}"
  echo "  HDR ITM target nits:   ${GAMESCOPE_HDR_NITS}"
  echo "  Force cursor grab:     ${FORCE_GRAB_CURSOR}"
  echo "  Low-latency/tearing:   ${LOW_LATENCY_TEARING} (KMS-only)"
  echo "  PipeWire debug mode:   ${PIPEWIRE_DEBUG_MODE}"
  echo "  PipeWire latency env: ${PIPEWIRE_LATENCY:-inherit}"
  echo "  Perf env preset:      ${PERF_ENV_PRESET:-0}"
  echo "  LD_PRELOAD mode:       ${LD_PRELOAD_MODE:-inherit}"
  echo "  Audio switch enabled:  ${AUDIO_SWITCH_ENABLED}"
  if (( AUDIO_SWITCH_ENABLED )); then
    local sink_desc
    sink_desc=$(audio_sink_display_name "$AUDIO_SINK_NAME")
    echo "  Audio sink name:       ${AUDIO_SINK_NAME:-"(unset)"}"
    echo "  Audio sink desc:       ${sink_desc:-"(unresolved)"}"
  fi
  if [[ -n "${AUTO_GBM_BACKENDS_PATH:-}" ]]; then
    echo "  NVIDIA Flatpak GBM:    ${AUTO_GBM_BACKENDS_PATH} (auto)"
  fi
  echo "  Inner payload:         $inner_label"
  echo "  Detach mode:           ${FLAG_DETACH}"
  echo

  launch_vanilla_gamescope "${inner_cmd[@]}"
}

interactive_new_config() {
  local from_menu=${1:-0}

  CURRENT_PROFILE=""
  PRE_CMD=""
  POST_CMD=""
  LD_PRELOAD_MODE="inherit"
  detect_session_mode

  # Reset refresh-related fields so new profile does NOT inherit previous rates.
  G_FPS=0
  G_FPS_BG=0

  local step=1
  while :; do
    case "$step" in
      1)
        if ! detect_steam_installations; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          echo "Aborting interactive setup."
          exit 0
        fi
        if ! choose_steam_launch_mode; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          echo "Aborting interactive setup."
          exit 0
        fi
        step=2
        ;;
      2)
        if ! choose_drm_output; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          step=3
        fi
        ;;
      3)
        if ! choose_resolution_profile; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          step=4
        fi
        ;;
      4)
        if ! choose_gamescope_rate; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          step=5
        fi
        ;;
      5)
        if ! choose_vrr_hdr_and_steamos; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          step=6
        fi
        ;;
      6)
        if ! choose_pipewire_debug; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          if ! choose_pipewire_latency; then
            if (( from_menu )); then
              echo "Returning to main menu."
              return 1
            fi
            step=$((step - 1))
          elif ! choose_perf_env_preset; then
            if (( from_menu )); then
              echo "Returning to main menu."
              return 1
            fi
            step=$((step - 1))
          else
            step=7
          fi
        fi
        ;;
      7)
        if ! choose_ld_preload_mode; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          step=8
        fi
        ;;
      8)
        if ! choose_audio_switch; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          step=9
        fi
        ;;
      9)
        if ! choose_pre_post_commands; then
          if (( from_menu )); then
            echo "Returning to main menu."
            return 1
          fi
          step=$((step - 1))
        else
          step=10
        fi
        ;;
      10)
        if ! save_config; then
          step=$((step - 1))
          continue
        fi

        # After saving a new profile, return to the main menu so the user can
        # review the settings and choose [1] to launch.
        load_profile_by_name "$CURRENT_PROFILE" >/dev/null 2>&1 || HAVE_CONFIG=1
        return 0
        ;;

      *)
        return 0
        ;;
    esac
  done
}

run_from_current_config() {
  detect_session_mode

  if [[ -z "$DRM_SHORT" || -z "$DRM_NATIVE_MODE" ]]; then
    echo "Config incomplete; re-running interactive setup."
    interactive_new_config 0
  fi

  if [[ -z "${STEAM_TYPE:-}" ]]; then
    STEAM_TYPE="native"
  fi

  PIPEWIRE_DEBUG_MODE=${PIPEWIRE_DEBUG_MODE:-2}
  PIPEWIRE_LATENCY=${PIPEWIRE_LATENCY:-inherit}
  PERF_ENV_PRESET=${PERF_ENV_PRESET:-0}
  FORCE_GRAB_CURSOR=${FORCE_GRAB_CURSOR:-0}
  LOW_LATENCY_TEARING=${LOW_LATENCY_TEARING:-0}
  LD_PRELOAD_MODE=${LD_PRELOAD_MODE:-inherit}
  G_FPS_BG=${G_FPS_BG:-0}
  AUDIO_SWITCH_ENABLED=${AUDIO_SWITCH_ENABLED:-0}
  AUDIO_SINK_NAME=${AUDIO_SINK_NAME:-""}
  PRE_CMD=${PRE_CMD:-""}
  POST_CMD=${POST_CMD:-""}

  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    if ! command -v flatpak >/dev/null 2>/dev/null || \
       ! flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
      print_warn "Saved config uses Steam Flatpak, but it is not available."
      if ! detect_steam_installations; then
        echo "Aborting launch."
        exit 0
      fi
      save_config || true
    fi
  elif [[ "$STEAM_TYPE" == "native" ]]; then
    if ! command -v steam >/dev/null 2>&1; then
      print_warn "Saved config uses native Steam, but it is not available."
      if ! detect_steam_installations; then
        echo "Aborting launch."
        exit 0
      fi
      save_config || true
    fi
  fi

  init_default_refresh_for_output

  if [[ "${STEAM_LAUNCH_MODE:-gamepad}" == "pipe" ]]; then
    launch_desktop_steam_if_needed || true
    print_pipe_instructions
    return 0
  fi

  handle_running_steam_before_launch
  launch_gamescope_session
}

generate_launch_opts() {
  if (( HAVE_CONFIG == 0 || FLAG_NEW )); then
    PRE_CMD=""
    POST_CMD=""
    detect_session_mode
    LD_PRELOAD_MODE="inherit"
    if ! detect_steam_installations; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_steam_launch_mode; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_drm_output; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_resolution_profile; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_gamescope_rate; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_vrr_hdr_and_steamos; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_pipewire_debug; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_ld_preload_mode; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_audio_switch; then
      echo "Aborting launch options generator."
      exit 0
    fi
    if ! choose_pre_post_commands; then
      echo "Aborting launch options generator."
      exit 0
    fi
    save_config || true
    HAVE_CONFIG=1
  fi

  init_default_refresh_for_output

  if [[ "${STEAM_LAUNCH_MODE:-gamepad}" == "pipe" ]]; then
    print_pipe_launch_options
  else
    print_steam_launch_options
  fi
  exit 0
}

kill_gamescope() {
  local had_gs=0
  local ended=0
  local state_profile=""
  local state_pid=0

  local -a gs_pids=()
  local -A seen=()

  if read_session_state; then
    state_profile="${SESSION_PROFILE:-}"
    state_pid="${SESSION_PID:-0}"
  fi

  # Load profile tied to the recorded session so POST_CMD matches.
  if [[ -n "$state_profile" ]]; then
    load_profile_by_name "$state_profile" >/dev/null 2>&1 || true
  fi

  # Prefer the recorded session PID if it is alive.
  if [[ "$state_pid" =~ ^[0-9]+$ ]] && (( state_pid > 0 )) && kill -0 "$state_pid" 2>/dev/null; then
    seen["$state_pid"]=1
    gs_pids+=("$state_pid")
  fi

  # Add any gamescope PIDs we can find (restricted to current UID to avoid multi-user weirdness).
  if command -v pgrep >/dev/null 2>&1; then
    local pid
    while IFS= read -r pid; do
      [[ -n "$pid" ]] || continue
      [[ -n "${seen[$pid]-}" ]] && continue
      seen["$pid"]=1
      gs_pids+=("$pid")
    done < <(pgrep -u "$UID" -x gamescope 2>/dev/null || true)

    # If exact-name match found nothing, fall back to cmdline match (still UID-limited).
    if (( ${#gs_pids[@]} == 0 )); then
      while IFS= read -r pid; do
        [[ -n "$pid" ]] || continue
        [[ -n "${seen[$pid]-}" ]] && continue
        seen["$pid"]=1
        gs_pids+=("$pid")
      done < <(pgrep -u "$UID" -f '(^|/)(gamescope)([[:space:]]|$)' 2>/dev/null || true)
    fi
  else
    # No pgrep: /proc scan (best-effort, UID filtering via ownership is not trivial without stat).
    local d pid comm cmdline
    for d in /proc/[0-9]*; do
      pid="${d#/proc/}"

      comm=""
      if IFS= read -r comm <"$d/comm" 2>/dev/null; then
        if [[ "$comm" == "gamescope" ]]; then
          [[ -n "${seen[$pid]-}" ]] || { seen["$pid"]=1; gs_pids+=("$pid"); }
          continue
        fi
      fi

      if [[ -r "$d/cmdline" ]]; then
        cmdline="$(tr '\0' ' ' <"$d/cmdline" 2>/dev/null || true)"
        if [[ "$cmdline" == *"gamescope"* ]]; then
          [[ -n "${seen[$pid]-}" ]] || { seen["$pid"]=1; gs_pids+=("$pid"); }
        fi
      fi
    done
  fi

  if (( ${#gs_pids[@]} > 0 )); then
    had_gs=1
  else
    echo "No gamescope processes found."
    audio_restore_from_state
    return 0
  fi

  print_info "Requesting Steam shutdown..."
  request_steam_shutdown || true

  # Wait for tracked PIDs to exit.
  local i any_alive
  for ((i = 0; i < 80; i++)); do
    any_alive=0
    local p
    for p in "${gs_pids[@]}"; do
      if [[ "$p" =~ ^[0-9]+$ ]] && kill -0 "$p" 2>/dev/null; then
        any_alive=1
        break
      fi
    done
    if (( ! any_alive )); then
      ended=1
      break
    fi
    sleep 0.25
  done

  if (( ended )); then
    print_success "Steam shutdown requested; gamescope session ended."
  else
    # Last-resort: TERM any still-alive tracked PIDs.
    print_warn "Steam shutdown did not end gamescope quickly; sending SIGTERM to remaining gamescope PIDs."
    local p
    for p in "${gs_pids[@]}"; do
      if [[ "$p" =~ ^[0-9]+$ ]] && kill -0 "$p" 2>/dev/null; then
        kill -TERM "$p" 2>/dev/null || true
      fi
    done

    for ((i = 0; i < 20; i++)); do
      any_alive=0
      for p in "${gs_pids[@]}"; do
        if [[ "$p" =~ ^[0-9]+$ ]] && kill -0 "$p" 2>/dev/null; then
          any_alive=1
          break
        fi
      done
      if (( ! any_alive )); then
        ended=1
        break
      fi
      sleep 0.25
    done

    if (( ended )); then
      print_success "gamescope exited after SIGTERM."
    else
      print_warn "gamescope still appears to be running."
    fi
  fi

  audio_restore_from_state

  # Only run/mark POST if the session actually ended here.
  if (( ended )); then
    if [[ "$state_pid" =~ ^[0-9]+$ ]] && (( state_pid > 0 )); then
      if ! post_already_ran_for_pid "$state_pid"; then
        run_post_hook
        mark_post_ran_for_pid "$state_pid"
      fi
    else
      run_post_hook
    fi
  fi

  return $had_gs
}

interactive_profile_menu() {
  smtty_load_locked_game_if_any || true
  while :; do
    detect_session_mode
    init_default_refresh_for_output
    print_config_summary
    if (( HAVE_CONFIG == 1 )); then
      local prof="${CURRENT_PROFILE:-}"
      [[ -z "$prof" ]] && prof="default"
      echo
      echo "Tip: Desktop Steam Launch Options for this profile:"
      if [[ "${STEAM_TYPE:-native}" == "flatpak" ]]; then
        echo "  flatpak-spawn --host smtty -c ${prof} -P -- %command%"
      else
        echo "  smtty -c ${prof} -P -- %command%"
      fi
    fi
    echo
    local lock_state="unlocked"
    [[ -f "$SMTTY_LOCKED_GAME_FILE" ]] && lock_state="LOCKED"
    if [[ -n "${SMTTY_APPLAUNCH_APPID:-}" ]]; then
      local disp_name="${SMTTY_APPLAUNCH_NAME:-}"
      [[ -z "$disp_name" ]] && disp_name="appid ${SMTTY_APPLAUNCH_APPID}"
      echo "Selected game: ${disp_name} (${SMTTY_APPLAUNCH_APPID}) [$lock_state]"
    else
      echo "Selected game: (none) [$lock_state]"
    fi
    echo
    local mh_state="OFF"
    if (( FLAG_MANGOHUD )); then
      mh_state="ON"
    fi

    echo "Options:"
    echo "  [G] Pick installed Steam game to auto-launch"
    echo "  [L] Lock selected game (persist across runs)"
    echo "  [U] Unlock selected game (stop persisting)"
    echo "  [M] Toggle MangoHud (currently: ${mh_state})"
    echo "  [D] Doctor (gamescope performance tips)"
    echo "  [C] Clear selected game"
    echo "  [V] Check smtty version"
    echo "  [1] Use this profile"
    echo "  [2] Select a different profile"
    echo "  [3] Create new profile"
    echo "  [4] Delete a profile"
    echo "  [b] Exit"

    local choice
    if ! read_one_key choice "Choose option [G,L,U,M,C,D,V,1-4,b]: " ; then
      echo "Exiting."
      exit 0
    fi
    case "$choice" in
      [Mm])
        if (( FLAG_MANGOHUD )); then
          FLAG_MANGOHUD=0
          echo "MangoHud: OFF"
        else
          if command -v mangohud >/dev/null 2>&1; then
            FLAG_MANGOHUD=1
            echo "MangoHud: ON"
          else
            detect_pkg_manager
            local pkg=""
            pkg="$(pkg_for_cmd mangohud || true)"
            echo "[ERROR] MangoHud is not installed."
            if [[ -n "$pkg" ]]; then
              echo "Install it and try again: $pkg"
            else
              echo "Install it and try again: mangohud"
            fi
            FLAG_MANGOHUD=0
          fi
        fi
        ;;
      1)
        run_from_current_config
        ;;
      2)
        if select_profile_interactive "use"; then
          # Load/switch profile only. Do NOT auto-launch.
          # This lets the user review the loaded settings, then choose [1] to launch,
          # or exit and run `smtty -O` to generate launch options for this profile.
          load_profile_by_name "$CURRENT_PROFILE" || true
        else
          echo "No other profiles available or selection cancelled."
        fi
        continue
        ;;
      3)
        if ! interactive_new_config 1; then
          continue
        fi
        continue
        ;;

      4)
        if select_profile_interactive "delete"; then
          delete_profile "$CURRENT_PROFILE" || true
        else
          echo "No profiles available to delete."
        fi
        continue
        ;;
    [Gg])
      if pick_installed_steam_game; then
        if [[ -f "$SMTTY_LOCKED_GAME_FILE" ]]; then
          rm -f "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null || true
          echo "Lock cleared (press [L] to lock this selection)."
        fi
      fi
      ;;
    [Dd])
      echo
      smtty_doctor
      echo
      read -r -p "Press Enter to return to menu..." _smtty_doc_pause || true
      ;;
    [Ll])
      smtty_lock_selected_game || true
      ;;
    [Uu])
      smtty_unlock_selected_game || true
      ;;
    [Cc])
      SMTTY_APPLAUNCH_APPID=""
      SMTTY_APPLAUNCH_NAME=""
      export SMTTY_APPLAUNCH_APPID SMTTY_APPLAUNCH_NAME
      rm -f "$SMTTY_LOCKED_GAME_FILE" 2>/dev/null || true
      echo "Selected game cleared."
      ;;
    [Vv])
      echo
      smtty_print_version
      echo
      read -r -p "Press Enter to return to menu..." _smtty_ver_pause || true
      ;;
      *)
      echo "Enter G, L, U, C, D, V, 1, 2, 3, 4, or b."
        ;;
    esac
  done
}

cleanup_old_session_artifacts() {
  # Best-effort: remove stale gamescope-session logs/pidfiles from crashes.
  # Keeps recent files (current run uses $$ anyway).
  command -v find >/dev/null 2>&1 || return 0
  [[ -d "$CONFIG_DIR" ]] || return 0

  # Remove anything older than 7 days.
  find "$CONFIG_DIR" -maxdepth 1 \
    \( -name 'gamescope-session.*.log' -o -name 'gamescope-session.*.pid' \) \
    -type f -mtime +7 -print0 2>/dev/null | xargs -0r rm -f 2>/dev/null || true
}

# ---------------- main ----------------
if [[ ${UID:-$(id -u)} -eq 0 ]]; then
  print_error "Do not run as root. Use your regular user account."
  exit 1
fi

cleanup_old_session_artifacts

# Support literal -PIPE token (Steam Launch Options convenience)
if (( $# > 0 )); then
  _argv=()
  for _a in "$@"; do
    if [[ "$_a" == "-PIPE" ]]; then
      _argv+=("-P")
    else
      _argv+=("$_a")
    fi
  done
  set -- "${_argv[@]}"
fi

while getopts ":hnlpkdOPSeMc:LD:" opt; do
  case "$opt" in
    h) FLAG_HELP=1 ;;
    n) FLAG_NEW=1 ;;
    l) FLAG_LAST=1 ;;
    p) FLAG_PRINT=1 ;;
    k) FLAG_KILL=1 ;;
    d) FLAG_DETACH=1 ;;
    O) FLAG_LAUNCH_OPTS=1 ;;
    P) FLAG_PIPE=1 ;;
    S) FLAG_KILL_STEAM=1 ;;
    e) FLAG_PIPE_STEAM_INTEGRATION=1 ;;
    M) FLAG_MANGOHUD=1 ;;
    c) SELECTED_PROFILE="$OPTARG" ;;
    L) FLAG_LIST_PROFILES=1 ;;
    D) FLAG_DELETE_PROFILE=1; SELECTED_PROFILE="$OPTARG" ;;
    \?) print_error "Unknown option: -$OPTARG"; exit 1 ;;
    :) print_error "Option -$OPTARG requires an argument"; exit 1 ;;
  esac
done
shift $((OPTIND - 1))

if (( FLAG_PIPE_STEAM_INTEGRATION )); then
  export SMTTY_PIPE_STEAM_INTEGRATION=1
fi

if (( FLAG_HELP )); then
  print_help
  exit 0
fi

if (( FLAG_LIST_PROFILES )); then
  list_profiles
  exit 0
fi

if (( FLAG_DELETE_PROFILE )); then
  if ! delete_profile "$SELECTED_PROFILE"; then
    exit 1
  fi
  exit 0
fi

# Load config by explicit -c first, else last_profile
if [[ -n "$SELECTED_PROFILE" && $FLAG_DELETE_PROFILE -eq 0 ]]; then
  if ! load_profile_by_name "$SELECTED_PROFILE"; then
    exit 1
  fi
else
  load_config_default
fi

if (( FLAG_PIPE )); then
  run_pipe_mode "$@"
  exit $?
fi

if (( FLAG_KILL )); then
  kill_gamescope
  exit 0
fi

if (( FLAG_LAUNCH_OPTS )); then
  generate_launch_opts
fi

if (( FLAG_PRINT )); then
  print_config_summary
  exit 0
fi

if [[ -n "$SELECTED_PROFILE" && $FLAG_DELETE_PROFILE -eq 0 ]]; then
  if (( HAVE_CONFIG == 0 )); then
    print_error "Profile '$SELECTED_PROFILE' not found."
    echo "Available profiles:"
    list_profiles
    exit 1
  fi
  run_from_current_config
fi

if (( FLAG_LAST )); then
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config; doing new interactive setup."
    if interactive_new_config 0; then
      interactive_profile_menu
    fi
    exit 0
  fi
  run_from_current_config
fi


if (( FLAG_NEW )); then
  if interactive_new_config 0; then
    interactive_profile_menu
  fi
  exit 0
fi


if (( HAVE_CONFIG == 0 )); then
  if select_profile_interactive "use"; then
    load_profile_by_name "$CURRENT_PROFILE" || true
  else
    if interactive_new_config 0; then
      interactive_profile_menu
    fi
    exit 0
  fi
fi


interactive_profile_menu
  print_profile_line "PipeWire latency env:"    "${PIPEWIRE_LATENCY:-inherit}" "(inherit or frames/rate)"
  print_profile_line "Perf env preset:"         "${PERF_ENV_PRESET:-0}"     "(0/1, vendor-aware)"
